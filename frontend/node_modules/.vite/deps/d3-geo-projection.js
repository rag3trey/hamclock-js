import {
  azimuthalEqualAreaRaw,
  azimuthalEquidistantRaw,
  bounds_default,
  centroid_default,
  circle_default,
  equirectangular_default,
  gnomonicRaw,
  gnomonic_default,
  interpolate_default,
  merge,
  orthographic_default,
  projection,
  projectionMutator,
  range,
  rotation_default,
  stream_default
} from "./chunk-TM2ZJIPI.js";
import "./chunk-4MBMRILA.js";

// node_modules/d3-geo-projection/src/math.js
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sin = Math.sin;
var tan = Math.tan;
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}
function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}
function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}
function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}
function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}
function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}

// node_modules/d3-geo-projection/src/airy.js
function airyRaw(beta) {
  var tanBeta_2 = tan(beta / 2), b = 2 * log(cos(beta / 2)) / (tanBeta_2 * tanBeta_2);
  function forward(x, y) {
    var cosx = cos(x), cosy = cos(y), siny = sin(y), cosz = cosy * cosx, k2 = -((1 - cosz ? log((1 + cosz) / 2) / (1 - cosz) : -0.5) + b / (1 + cosz));
    return [k2 * cosy * sin(x), k2 * siny];
  }
  forward.invert = function(x, y) {
    var r = sqrt(x * x + y * y), z = -beta / 2, i = 50, delta;
    if (!r) return [0, 0];
    do {
      var z_2 = z / 2, cosz_2 = cos(z_2), sinz_2 = sin(z_2), tanz_2 = sinz_2 / cosz_2, lnsecz_2 = -log(abs(cosz_2));
      z -= delta = (2 / tanz_2 * lnsecz_2 - b * tanz_2 - r) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b / (2 * cosz_2 * cosz_2)) * (cosz_2 < 0 ? 0.7 : 1);
    } while (abs(delta) > epsilon && --i > 0);
    var sinz = sin(z);
    return [atan2(x * sinz, r * cos(z)), asin(y * sinz / r)];
  };
  return forward;
}
function airy_default() {
  var beta = halfPi, m = projectionMutator(airyRaw), p = m(beta);
  p.radius = function(_) {
    return arguments.length ? m(beta = _ * radians) : beta * degrees;
  };
  return p.scale(179.976).clipAngle(147);
}

// node_modules/d3-geo-projection/src/aitoff.js
function aitoffRaw(x, y) {
  var cosy = cos(y), sincia = sinci(acos(cosy * cos(x /= 2)));
  return [2 * cosy * sin(x) * sincia, sin(y) * sincia];
}
aitoffRaw.invert = function(x, y) {
  if (x * x + 4 * y * y > pi * pi + epsilon) return;
  var x12 = x, y12 = y, i = 25;
  do {
    var sinx = sin(x12), sinx_2 = sin(x12 / 2), cosx_2 = cos(x12 / 2), siny = sin(y12), cosy = cos(y12), sin_2y = sin(2 * y12), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c = 1 - cos2y * cosx_2 * cosx_2, e = c ? acos(cosy * cosx_2) * sqrt(f = 1 / c) : f = 0, f, fx = 2 * e * cosy * sinx_2 - x, fy = e * siny - y, dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;
    if (!z) break;
    var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;
    x12 -= dx, y12 -= dy;
  } while ((abs(dx) > epsilon || abs(dy) > epsilon) && --i > 0);
  return [x12, y12];
};
function aitoff_default() {
  return projection(aitoffRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/armadillo.js
function armadilloRaw(phi02) {
  var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02), sPhi0 = phi02 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi02), k2 = (1 + sinPhi0 - cosPhi0) / 2;
  function forward(lambda, phi) {
    var cosPhi = cos(phi), cosLambda = cos(lambda /= 2);
    return [
      (1 + cosPhi) * sin(lambda),
      (sPhi0 * phi > -atan2(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k2 + sin(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda
      // TODO D3 core should allow null or [NaN, NaN] to be returned.
    ];
  }
  forward.invert = function(x, y) {
    var lambda = 0, phi = 0, i = 50;
    do {
      var cosLambda = cos(lambda), sinLambda = sin(lambda), cosPhi = cos(phi), sinPhi = sin(phi), A2 = 1 + cosPhi, fx = A2 * sinLambda - x, fy = k2 + sinPhi * cosPhi0 - A2 * sinPhi0 * cosLambda - y, dxdLambda = A2 * cosLambda / 2, dxdPhi = -sinLambda * sinPhi, dydLambda = sinPhi0 * A2 * sinLambda / 2, dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi, denominator = dxdPhi * dydLambda - dydPhi * dxdLambda, dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2, dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;
      if (abs(dPhi) > 2) dPhi /= 2;
      lambda -= dLambda, phi -= dPhi;
    } while ((abs(dLambda) > epsilon || abs(dPhi) > epsilon) && --i > 0);
    return sPhi0 * phi > -atan2(cos(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;
  };
  return forward;
}
function armadillo_default() {
  var phi02 = 20 * radians, sPhi0 = phi02 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi02), m = projectionMutator(armadilloRaw), p = m(phi02), stream_ = p.stream;
  p.parallel = function(_) {
    if (!arguments.length) return phi02 * degrees;
    tanPhi0 = tan((sPhi0 = (phi02 = _ * radians) >= 0 ? 1 : -1) * phi02);
    return m(phi02);
  };
  p.stream = function(stream) {
    var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream)), precision = p.precision();
    p.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart(), sphereStream.lineStart();
      for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90)
        sphereStream.point(lambda, sPhi0 * 90);
      if (phi02) while (sPhi0 * (lambda -= 3 * sPhi0 * precision) >= -180) {
        sphereStream.point(lambda, sPhi0 * -atan2(cos(lambda * radians / 2), tanPhi0) * degrees);
      }
      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return p.scale(218.695).center([0, 28.0974]);
}

// node_modules/d3-geo-projection/src/august.js
function augustRaw(lambda, phi) {
  var tanPhi = tan(phi / 2), k2 = sqrt(1 - tanPhi * tanPhi), c = 1 + k2 * cos(lambda /= 2), x = sin(lambda) * k2 / c, y = tanPhi / c, x2 = x * x, y2 = y * y;
  return [
    4 / 3 * x * (3 + x2 - 3 * y2),
    4 / 3 * y * (3 + 3 * x2 - y2)
  ];
}
augustRaw.invert = function(x, y) {
  x *= 3 / 8, y *= 3 / 8;
  if (!x && abs(y) > 1) return null;
  var x2 = x * x, y2 = y * y, s = 1 + x2 + y2, sin3Eta = sqrt((s - sqrt(s * s - 4 * y * y)) / 2), eta = asin(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs(y / sin3Eta)) / 3 : arsinh(abs(x)) / 3, cosEta = cos(eta), coshXi = cosh(xi), d = coshXi * coshXi - cosEta * cosEta;
  return [
    sign(x) * 2 * atan2(sinh(xi) * cosEta, 0.25 - d),
    sign(y) * 2 * atan2(coshXi * sin(eta), 0.25 + d)
  ];
};
function august_default() {
  return projection(augustRaw).scale(66.1603);
}

// node_modules/d3-geo-projection/src/baker.js
var sqrt8 = sqrt(8);
var phi0 = log(1 + sqrt2);
function bakerRaw(lambda, phi) {
  var phi02 = abs(phi);
  return phi02 < quarterPi ? [lambda, log(tan(quarterPi + phi / 2))] : [lambda * cos(phi02) * (2 * sqrt2 - 1 / sin(phi02)), sign(phi) * (2 * sqrt2 * (phi02 - quarterPi) - log(tan(phi02 / 2)))];
}
bakerRaw.invert = function(x, y) {
  if ((y02 = abs(y)) < phi0) return [x, 2 * atan(exp(y)) - halfPi];
  var phi = quarterPi, i = 25, delta, y02;
  do {
    var cosPhi_2 = cos(phi / 2), tanPhi_2 = tan(phi / 2);
    phi -= delta = (sqrt8 * (phi - quarterPi) - log(tanPhi_2) - y02) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
  } while (abs(delta) > epsilon2 && --i > 0);
  return [x / (cos(phi) * (sqrt8 - 1 / sin(phi))), sign(y) * phi];
};
function baker_default() {
  return projection(bakerRaw).scale(112.314);
}

// node_modules/d3-geo-projection/src/berghaus.js
function berghausRaw(lobes8) {
  var k2 = 2 * pi / lobes8;
  function forward(lambda, phi) {
    var p = azimuthalEquidistantRaw(lambda, phi);
    if (abs(lambda) > halfPi) {
      var theta = atan2(p[1], p[0]), r = sqrt(p[0] * p[0] + p[1] * p[1]), theta0 = k2 * round((theta - halfPi) / k2) + halfPi, alpha = atan2(sin(theta -= theta0), 2 - cos(theta));
      theta = theta0 + asin(pi / r * sin(alpha)) - alpha;
      p[0] = r * cos(theta);
      p[1] = r * sin(theta);
    }
    return p;
  }
  forward.invert = function(x, y) {
    var r = sqrt(x * x + y * y);
    if (r > halfPi) {
      var theta = atan2(y, x), theta0 = k2 * round((theta - halfPi) / k2) + halfPi, s = theta > theta0 ? -1 : 1, A2 = r * cos(theta0 - theta), cotAlpha = 1 / tan(s * acos((A2 - pi) / sqrt(pi * (pi - 2 * A2) + r * r)));
      theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);
      x = r * cos(theta), y = r * sin(theta);
    }
    return azimuthalEquidistantRaw.invert(x, y);
  };
  return forward;
}
function berghaus_default() {
  var lobes8 = 5, m = projectionMutator(berghausRaw), p = m(lobes8), projectionStream = p.stream, epsilon4 = 0.01, cr = -cos(epsilon4 * radians), sr = sin(epsilon4 * radians);
  p.lobes = function(_) {
    return arguments.length ? m(lobes8 = +_) : lobes8;
  };
  p.stream = function(stream) {
    var rotate = p.rotate(), rotateStream = projectionStream(stream), sphereStream = (p.rotate([0, 0]), projectionStream(stream));
    p.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart(), sphereStream.lineStart();
      for (var i = 0, delta = 360 / lobes8, delta0 = 2 * pi / lobes8, phi = 90 - 180 / lobes8, phi02 = halfPi; i < lobes8; ++i, phi -= delta, phi02 -= delta0) {
        sphereStream.point(atan2(sr * cos(phi02), cr) * degrees, asin(sr * sin(phi02)) * degrees);
        if (phi < -90) {
          sphereStream.point(-90, -180 - phi - epsilon4);
          sphereStream.point(-90, -180 - phi + epsilon4);
        } else {
          sphereStream.point(90, phi + epsilon4);
          sphereStream.point(90, phi - epsilon4);
        }
      }
      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return p.scale(87.8076).center([0, 17.1875]).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo-projection/src/hammer.js
function hammerRaw(A2, B2) {
  if (arguments.length < 2) B2 = A2;
  if (B2 === 1) return azimuthalEqualAreaRaw;
  if (B2 === Infinity) return hammerQuarticAuthalicRaw;
  function forward(lambda, phi) {
    var coordinates = azimuthalEqualAreaRaw(lambda / B2, phi);
    coordinates[0] *= A2;
    return coordinates;
  }
  forward.invert = function(x, y) {
    var coordinates = azimuthalEqualAreaRaw.invert(x / A2, y);
    coordinates[0] *= B2;
    return coordinates;
  };
  return forward;
}
function hammerQuarticAuthalicRaw(lambda, phi) {
  return [
    lambda * cos(phi) / cos(phi /= 2),
    2 * sin(phi)
  ];
}
hammerQuarticAuthalicRaw.invert = function(x, y) {
  var phi = 2 * asin(y / 2);
  return [
    x * cos(phi / 2) / cos(phi),
    phi
  ];
};
function hammer_default() {
  var B2 = 2, m = projectionMutator(hammerRaw), p = m(B2);
  p.coefficient = function(_) {
    if (!arguments.length) return B2;
    return m(B2 = +_);
  };
  return p.scale(169.529);
}

// node_modules/d3-geo-projection/src/newton.js
function solve(f, y, x) {
  var steps = 100, delta, f0, f1;
  x = x === void 0 ? 0 : +x;
  y = +y;
  do {
    f0 = f(x);
    f1 = f(x + epsilon);
    if (f0 === f1) f1 = f0 + epsilon;
    x -= delta = -1 * epsilon * (f0 - y) / (f0 - f1);
  } while (steps-- > 0 && abs(delta) > epsilon);
  return steps < 0 ? NaN : x;
}
function solve2d(f, MAX_ITERATIONS, eps) {
  if (MAX_ITERATIONS === void 0) MAX_ITERATIONS = 40;
  if (eps === void 0) eps = epsilon2;
  return function(x, y, a, b) {
    var err2, da, db;
    a = a === void 0 ? 0 : +a;
    b = b === void 0 ? 0 : +b;
    for (var i = 0; i < MAX_ITERATIONS; i++) {
      var p = f(a, b), tx = p[0] - x, ty = p[1] - y;
      if (abs(tx) < eps && abs(ty) < eps) break;
      var h = tx * tx + ty * ty;
      if (h > err2) {
        a -= da /= 2;
        b -= db /= 2;
        continue;
      }
      err2 = h;
      var ea = (a > 0 ? -1 : 1) * eps, eb = (b > 0 ? -1 : 1) * eps, pa = f(a + ea, b), pb = f(a, b + eb), dxa = (pa[0] - p[0]) / ea, dya = (pa[1] - p[1]) / ea, dxb = (pb[0] - p[0]) / eb, dyb = (pb[1] - p[1]) / eb, D = dyb * dxa - dya * dxb, l = (abs(D) < 0.5 ? 0.5 : 1) / D;
      da = (ty * dxb - tx * dyb) * l;
      db = (tx * dya - ty * dxa) * l;
      a += da;
      b += db;
      if (abs(da) < eps && abs(db) < eps) break;
    }
    return [a, b];
  };
}

// node_modules/d3-geo-projection/src/bertin.js
function bertin1953Raw() {
  var hammer = hammerRaw(1.68, 2), fu = 1.4, k2 = 12;
  function forward(lambda, phi) {
    if (lambda + phi < -fu) {
      var u = (lambda - phi + 1.6) * (lambda + phi + fu) / 8;
      lambda += u;
      phi -= 0.8 * u * sin(phi + pi / 2);
    }
    var r = hammer(lambda, phi);
    var d = (1 - cos(lambda * phi)) / k2;
    if (r[1] < 0) {
      r[0] *= 1 + d;
    }
    if (r[1] > 0) {
      r[1] *= 1 + d / 1.5 * r[0] * r[0];
    }
    return r;
  }
  forward.invert = solve2d(forward);
  return forward;
}
function bertin_default() {
  return projection(bertin1953Raw()).rotate([-16.5, -42]).scale(176.57).center([7.93, 0.09]);
}

// node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * sin(phi), i = 30, delta;
  do
    phi -= delta = (phi + sin(phi) - cpsinPhi) / (1 + cos(phi));
  while (abs(delta) > epsilon && --i > 0);
  return phi / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi) {
    return [cx * lambda * cos(phi = mollweideBromleyTheta(cp, phi)), cy * sin(phi)];
  }
  forward.invert = function(x, y) {
    return y = asin(y / cy), [x / (cx * cos(y)), asin((2 * y + sin(2 * y)) / cp)];
  };
  return forward;
}
var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);
function mollweide_default() {
  return projection(mollweideRaw).scale(169.529);
}

// node_modules/d3-geo-projection/src/boggs.js
var k = 2.00276;
var w = 1.11072;
function boggsRaw(lambda, phi) {
  var theta = mollweideBromleyTheta(pi, phi);
  return [k * lambda / (1 / cos(phi) + w / cos(theta)), (phi + sqrt2 * sin(theta)) / k];
}
boggsRaw.invert = function(x, y) {
  var ky = k * y, theta = y < 0 ? -quarterPi : quarterPi, i = 25, delta, phi;
  do {
    phi = ky - sqrt2 * sin(theta);
    theta -= delta = (sin(2 * theta) + 2 * theta - pi * sin(phi)) / (2 * cos(2 * theta) + 2 + pi * cos(phi) * sqrt2 * cos(theta));
  } while (abs(delta) > epsilon && --i > 0);
  phi = ky - sqrt2 * sin(theta);
  return [x * (1 / cos(phi) + w / cos(theta)) / k, phi];
};
function boggs_default() {
  return projection(boggsRaw).scale(160.857);
}

// node_modules/d3-geo-projection/src/parallel1.js
function parallel1_default(projectAt) {
  var phi02 = 0, m = projectionMutator(projectAt), p = m(phi02);
  p.parallel = function(_) {
    return arguments.length ? m(phi02 = _ * radians) : phi02 * degrees;
  };
  return p;
}

// node_modules/d3-geo-projection/src/sinusoidal.js
function sinusoidalRaw(lambda, phi) {
  return [lambda * cos(phi), phi];
}
sinusoidalRaw.invert = function(x, y) {
  return [x / cos(y), y];
};
function sinusoidal_default() {
  return projection(sinusoidalRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/bonne.js
function bonneRaw(phi02) {
  if (!phi02) return sinusoidalRaw;
  var cotPhi0 = 1 / tan(phi02);
  function forward(lambda, phi) {
    var rho = cotPhi0 + phi02 - phi, e = rho ? lambda * cos(phi) / rho : rho;
    return [rho * sin(e), cotPhi0 - rho * cos(e)];
  }
  forward.invert = function(x, y) {
    var rho = sqrt(x * x + (y = cotPhi0 - y) * y), phi = cotPhi0 + phi02 - rho;
    return [rho / cos(phi) * atan2(x, y), phi];
  };
  return forward;
}
function bonne_default() {
  return parallel1_default(bonneRaw).scale(123.082).center([0, 26.1441]).parallel(45);
}

// node_modules/d3-geo-projection/src/bottomley.js
function bottomleyRaw(sinPsi) {
  function forward(lambda, phi) {
    var rho = halfPi - phi, eta = rho ? lambda * sinPsi * sin(rho) / rho : rho;
    return [rho * sin(eta) / sinPsi, halfPi - rho * cos(eta)];
  }
  forward.invert = function(x, y) {
    var x12 = x * sinPsi, y12 = halfPi - y, rho = sqrt(x12 * x12 + y12 * y12), eta = atan2(x12, y12);
    return [(rho ? rho / sin(rho) : 1) * eta / sinPsi, halfPi - rho];
  };
  return forward;
}
function bottomley_default() {
  var sinPsi = 0.5, m = projectionMutator(bottomleyRaw), p = m(sinPsi);
  p.fraction = function(_) {
    return arguments.length ? m(sinPsi = +_) : sinPsi;
  };
  return p.scale(158.837);
}

// node_modules/d3-geo-projection/src/bromley.js
var bromleyRaw = mollweideBromleyRaw(1, 4 / pi, pi);
function bromley_default() {
  return projection(bromleyRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/chamberlin.js
function distance(dPhi, c1, s1, c2, s2, dLambda) {
  var cosdLambda = cos(dLambda), r;
  if (abs(dPhi) > 1 || abs(dLambda) > 1) {
    r = acos(s1 * s2 + c1 * c2 * cosdLambda);
  } else {
    var sindPhi = sin(dPhi / 2), sindLambda = sin(dLambda / 2);
    r = 2 * asin(sqrt(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));
  }
  return abs(r) > epsilon ? [r, atan2(c2 * sin(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];
}
function angle(b, c, a) {
  return acos((b * b + c * c - a * a) / (2 * b * c));
}
function longitude(lambda) {
  return lambda - 2 * pi * floor((lambda + pi) / (2 * pi));
}
function chamberlinRaw(p0, p1, p2) {
  var points2 = [
    [p0[0], p0[1], sin(p0[1]), cos(p0[1])],
    [p1[0], p1[1], sin(p1[1]), cos(p1[1])],
    [p2[0], p2[1], sin(p2[1]), cos(p2[1])]
  ];
  for (var a = points2[2], b, i = 0; i < 3; ++i, a = b) {
    b = points2[i];
    a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
    a.point = [0, 0];
  }
  var beta0 = angle(points2[0].v[0], points2[2].v[0], points2[1].v[0]), beta1 = angle(points2[0].v[0], points2[1].v[0], points2[2].v[0]), beta2 = pi - beta0;
  points2[2].point[1] = 0;
  points2[0].point[0] = -(points2[1].point[0] = points2[0].v[0] / 2);
  var mean = [
    points2[2].point[0] = points2[0].point[0] + points2[2].v[0] * cos(beta0),
    2 * (points2[0].point[1] = points2[1].point[1] = points2[2].v[0] * sin(beta0))
  ];
  function forward(lambda, phi) {
    var sinPhi = sin(phi), cosPhi = cos(phi), v = new Array(3), i2;
    for (i2 = 0; i2 < 3; ++i2) {
      var p = points2[i2];
      v[i2] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);
      if (!v[i2][0]) return p.point;
      v[i2][1] = longitude(v[i2][1] - p.v[1]);
    }
    var point = mean.slice();
    for (i2 = 0; i2 < 3; ++i2) {
      var j = i2 == 2 ? 0 : i2 + 1;
      var a2 = angle(points2[i2].v[0], v[i2][0], v[j][0]);
      if (v[i2][1] < 0) a2 = -a2;
      if (!i2) {
        point[0] += v[i2][0] * cos(a2);
        point[1] -= v[i2][0] * sin(a2);
      } else if (i2 == 1) {
        a2 = beta1 - a2;
        point[0] -= v[i2][0] * cos(a2);
        point[1] -= v[i2][0] * sin(a2);
      } else {
        a2 = beta2 - a2;
        point[0] += v[i2][0] * cos(a2);
        point[1] += v[i2][0] * sin(a2);
      }
    }
    point[0] /= 3, point[1] /= 3;
    return point;
  }
  return forward;
}
function pointRadians(p) {
  return p[0] *= radians, p[1] *= radians, p;
}
function chamberlinAfrica() {
  return chamberlin([0, 22], [45, 22], [22.5, -22]).scale(380).center([22.5, 2]);
}
function chamberlin(p0, p1, p2) {
  var c = centroid_default({ type: "MultiPoint", coordinates: [p0, p1, p2] }), R = [-c[0], -c[1]], r = rotation_default(R), f = chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)));
  f.invert = solve2d(f);
  var p = projection(f).rotate(R), center = p.center;
  delete p.rotate;
  p.center = function(_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };
  return p.clipAngle(90);
}

// node_modules/d3-geo-projection/src/collignon.js
function collignonRaw(lambda, phi) {
  var alpha = sqrt(1 - sin(phi));
  return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
}
collignonRaw.invert = function(x, y) {
  var lambda = (lambda = y / sqrtPi - 1) * lambda;
  return [lambda > 0 ? x * sqrt(pi / lambda) / 2 : 0, asin(1 - lambda)];
};
function collignon_default() {
  return projection(collignonRaw).scale(95.6464).center([0, 30]);
}

// node_modules/d3-geo-projection/src/craig.js
function craigRaw(phi02) {
  var tanPhi0 = tan(phi02);
  function forward(lambda, phi) {
    return [lambda, (lambda ? lambda / sin(lambda) : 1) * (sin(phi) * cos(lambda) - tanPhi0 * cos(phi))];
  }
  forward.invert = tanPhi0 ? function(x, y) {
    if (x) y *= sin(x) / x;
    var cosLambda = cos(x);
    return [x, 2 * atan2(sqrt(cosLambda * cosLambda + tanPhi0 * tanPhi0 - y * y) - cosLambda, tanPhi0 - y)];
  } : function(x, y) {
    return [x, asin(x ? y * tan(x) / x : y)];
  };
  return forward;
}
function craig_default() {
  return parallel1_default(craigRaw).scale(249.828).clipAngle(90);
}

// node_modules/d3-geo-projection/src/craster.js
var sqrt3 = sqrt(3);
function crasterRaw(lambda, phi) {
  return [sqrt3 * lambda * (2 * cos(2 * phi / 3) - 1) / sqrtPi, sqrt3 * sqrtPi * sin(phi / 3)];
}
crasterRaw.invert = function(x, y) {
  var phi = 3 * asin(y / (sqrt3 * sqrtPi));
  return [sqrtPi * x / (sqrt3 * (2 * cos(2 * phi / 3) - 1)), phi];
};
function craster_default() {
  return projection(crasterRaw).scale(156.19);
}

// node_modules/d3-geo-projection/src/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi0 = cos(phi02);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }
  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };
  return forward;
}
function cylindricalEqualArea_default() {
  return parallel1_default(cylindricalEqualAreaRaw).parallel(38.58).scale(195.044);
}

// node_modules/d3-geo-projection/src/cylindricalStereographic.js
function cylindricalStereographicRaw(phi02) {
  var cosPhi0 = cos(phi02);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, (1 + cosPhi0) * tan(phi / 2)];
  }
  forward.invert = function(x, y) {
    return [x / cosPhi0, atan(y / (1 + cosPhi0)) * 2];
  };
  return forward;
}
function cylindricalStereographic_default() {
  return parallel1_default(cylindricalStereographicRaw).scale(124.75);
}

// node_modules/d3-geo-projection/src/eckert1.js
function eckert1Raw(lambda, phi) {
  var alpha = sqrt(8 / (3 * pi));
  return [
    alpha * lambda * (1 - abs(phi) / pi),
    alpha * phi
  ];
}
eckert1Raw.invert = function(x, y) {
  var alpha = sqrt(8 / (3 * pi)), phi = y / alpha;
  return [
    x / (alpha * (1 - abs(phi) / pi)),
    phi
  ];
};
function eckert1_default() {
  return projection(eckert1Raw).scale(165.664);
}

// node_modules/d3-geo-projection/src/eckert2.js
function eckert2Raw(lambda, phi) {
  var alpha = sqrt(4 - 3 * sin(abs(phi)));
  return [
    2 / sqrt(6 * pi) * lambda * alpha,
    sign(phi) * sqrt(2 * pi / 3) * (2 - alpha)
  ];
}
eckert2Raw.invert = function(x, y) {
  var alpha = 2 - abs(y) / sqrt(2 * pi / 3);
  return [
    x * sqrt(6 * pi) / (2 * alpha),
    sign(y) * asin((4 - alpha * alpha) / 3)
  ];
};
function eckert2_default() {
  return projection(eckert2Raw).scale(165.664);
}

// node_modules/d3-geo-projection/src/eckert3.js
function eckert3Raw(lambda, phi) {
  var k2 = sqrt(pi * (4 + pi));
  return [
    2 / k2 * lambda * (1 + sqrt(1 - 4 * phi * phi / (pi * pi))),
    4 / k2 * phi
  ];
}
eckert3Raw.invert = function(x, y) {
  var k2 = sqrt(pi * (4 + pi)) / 2;
  return [
    x * k2 / (1 + sqrt(1 - y * y * (4 + pi) / (4 * pi))),
    y * k2 / 2
  ];
};
function eckert3_default() {
  return projection(eckert3Raw).scale(180.739);
}

// node_modules/d3-geo-projection/src/eckert4.js
function eckert4Raw(lambda, phi) {
  var k2 = (2 + halfPi) * sin(phi);
  phi /= 2;
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {
    var cosPhi = cos(phi);
    phi -= delta = (phi + sin(phi) * (cosPhi + 2) - k2) / (2 * cosPhi * (1 + cosPhi));
  }
  return [
    2 / sqrt(pi * (4 + pi)) * lambda * (1 + cos(phi)),
    2 * sqrt(pi / (4 + pi)) * sin(phi)
  ];
}
eckert4Raw.invert = function(x, y) {
  var A2 = y * sqrt((4 + pi) / pi) / 2, k2 = asin(A2), c = cos(k2);
  return [
    x / (2 / sqrt(pi * (4 + pi)) * (1 + c)),
    asin((k2 + A2 * (c + 2)) / (2 + halfPi))
  ];
};
function eckert4_default() {
  return projection(eckert4Raw).scale(180.739);
}

// node_modules/d3-geo-projection/src/eckert5.js
function eckert5Raw(lambda, phi) {
  return [
    lambda * (1 + cos(phi)) / sqrt(2 + pi),
    2 * phi / sqrt(2 + pi)
  ];
}
eckert5Raw.invert = function(x, y) {
  var k2 = sqrt(2 + pi), phi = y * k2 / 2;
  return [
    k2 * x / (1 + cos(phi)),
    phi
  ];
};
function eckert5_default() {
  return projection(eckert5Raw).scale(173.044);
}

// node_modules/d3-geo-projection/src/eckert6.js
function eckert6Raw(lambda, phi) {
  var k2 = (1 + halfPi) * sin(phi);
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {
    phi -= delta = (phi + sin(phi) - k2) / (1 + cos(phi));
  }
  k2 = sqrt(2 + pi);
  return [
    lambda * (1 + cos(phi)) / k2,
    2 * phi / k2
  ];
}
eckert6Raw.invert = function(x, y) {
  var j = 1 + halfPi, k2 = sqrt(j / 2);
  return [
    x * 2 * k2 / (1 + cos(y *= k2)),
    asin((y + sin(y)) / j)
  ];
};
function eckert6_default() {
  return projection(eckert6Raw).scale(173.044);
}

// node_modules/d3-geo-projection/src/eisenlohr.js
var eisenlohrK = 3 + 2 * sqrt2;
function eisenlohrRaw(lambda, phi) {
  var s0 = sin(lambda /= 2), c0 = cos(lambda), k2 = sqrt(cos(phi)), c1 = cos(phi /= 2), t = sin(phi) / (c1 + sqrt2 * c0 * k2), c = sqrt(2 / (1 + t * t)), v = sqrt((sqrt2 * c1 + (c0 + s0) * k2) / (sqrt2 * c1 + (c0 - s0) * k2));
  return [
    eisenlohrK * (c * (v - 1 / v) - 2 * log(v)),
    eisenlohrK * (c * t * (v + 1 / v) - 2 * atan(t))
  ];
}
eisenlohrRaw.invert = function(x, y) {
  if (!(p = augustRaw.invert(x / 1.2, y * 1.065))) return null;
  var lambda = p[0], phi = p[1], i = 20, p;
  x /= eisenlohrK, y /= eisenlohrK;
  do {
    var _0 = lambda / 2, _1 = phi / 2, s0 = sin(_0), c0 = cos(_0), s1 = sin(_1), c1 = cos(_1), cos1 = cos(phi), k2 = sqrt(cos1), t = s1 / (c1 + sqrt2 * c0 * k2), t2 = t * t, c = sqrt(2 / (1 + t2)), v0 = sqrt2 * c1 + (c0 + s0) * k2, v1 = sqrt2 * c1 + (c0 - s0) * k2, v2 = v0 / v1, v = sqrt(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * log(v) - x, fy = c * t * vp1v - 2 * atan(t) - y, deltatDeltaLambda = s1 && sqrt1_2 * k2 * s0 * t2 / s1, deltatDeltaPhi = (sqrt2 * c0 * c1 + k2) / (2 * (c1 + sqrt2 * c0 * k2) * (c1 + sqrt2 * c0 * k2) * k2), deltacDeltat = -0.5 * t * c * c * c, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A2 = (A2 = 2 * c1 + sqrt2 * k2 * (c0 - s0)) * A2 * v, deltavDeltaLambda = (sqrt2 * c0 * c1 * k2 + cos1) / A2, deltavDeltaPhi = -(sqrt2 * s0 * s1) / (k2 * A2), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
    if (!denominator) break;
    var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda;
    phi = max(-halfPi, min(halfPi, phi - deltaPhi));
  } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
  return abs(abs(phi) - halfPi) < epsilon ? [0, phi] : i && [lambda, phi];
};
function eisenlohr_default() {
  return projection(eisenlohrRaw).scale(62.5271);
}

// node_modules/d3-geo-projection/src/fahey.js
var faheyK = cos(35 * radians);
function faheyRaw(lambda, phi) {
  var t = tan(phi / 2);
  return [lambda * faheyK * sqrt(1 - t * t), (1 + faheyK) * t];
}
faheyRaw.invert = function(x, y) {
  var t = y / (1 + faheyK);
  return [x && x / (faheyK * sqrt(1 - t * t)), 2 * atan(t)];
};
function fahey_default() {
  return projection(faheyRaw).scale(137.152);
}

// node_modules/d3-geo-projection/src/foucaut.js
function foucautRaw(lambda, phi) {
  var k2 = phi / 2, cosk = cos(k2);
  return [2 * lambda / sqrtPi * cos(phi) * cosk * cosk, sqrtPi * tan(k2)];
}
foucautRaw.invert = function(x, y) {
  var k2 = atan(y / sqrtPi), cosk = cos(k2), phi = 2 * k2;
  return [x * sqrtPi / 2 / (cos(phi) * cosk * cosk), phi];
};
function foucaut_default() {
  return projection(foucautRaw).scale(135.264);
}

// node_modules/d3-geo-projection/src/foucautSinusoidal.js
function foucautSinusoidalRaw(alpha) {
  var beta = 1 - alpha, equatorial = raw(pi, 0)[0] - raw(-pi, 0)[0], polar = raw(0, halfPi)[1] - raw(0, -halfPi)[1], ratio = sqrt(2 * polar / equatorial);
  function raw(lambda, phi) {
    var cosphi = cos(phi), sinphi = sin(phi);
    return [
      cosphi / (beta + alpha * cosphi) * lambda,
      beta * phi + alpha * sinphi
    ];
  }
  function forward(lambda, phi) {
    var p = raw(lambda, phi);
    return [p[0] * ratio, p[1] / ratio];
  }
  function forwardMeridian(phi) {
    return forward(0, phi)[1];
  }
  forward.invert = function(x, y) {
    var phi = solve(forwardMeridian, y), lambda = x / ratio * (alpha + beta / cos(phi));
    return [lambda, phi];
  };
  return forward;
}
function foucautSinusoidal_default() {
  var alpha = 0.5, m = projectionMutator(foucautSinusoidalRaw), p = m(alpha);
  p.alpha = function(_) {
    return arguments.length ? m(alpha = +_) : alpha;
  };
  return p.scale(168.725);
}

// node_modules/d3-geo-projection/src/gilbert.js
function gilbertForward(point) {
  return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];
}
function gilbertInvert(point) {
  return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];
}
function gilbert_default(projectionType) {
  if (projectionType == null) projectionType = orthographic_default;
  var projection2 = projectionType(), equirectangular = equirectangular_default().scale(degrees).precision(0).clipAngle(null).translate([0, 0]);
  function gilbert(point) {
    return projection2(gilbertForward(point));
  }
  if (projection2.invert) gilbert.invert = function(point) {
    return gilbertInvert(projection2.invert(point));
  };
  gilbert.stream = function(stream) {
    var s1 = projection2.stream(stream), s0 = equirectangular.stream({
      point: function(lambda, phi) {
        s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees);
      },
      lineStart: function() {
        s1.lineStart();
      },
      lineEnd: function() {
        s1.lineEnd();
      },
      polygonStart: function() {
        s1.polygonStart();
      },
      polygonEnd: function() {
        s1.polygonEnd();
      }
    });
    s0.sphere = s1.sphere;
    return s0;
  };
  function property(name) {
    gilbert[name] = function() {
      return arguments.length ? (projection2[name].apply(projection2, arguments), gilbert) : projection2[name]();
    };
  }
  gilbert.rotate = function(_) {
    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();
  };
  gilbert.center = function(_) {
    return arguments.length ? (projection2.center(gilbertForward(_)), gilbert) : gilbertInvert(projection2.center());
  };
  property("angle");
  property("clipAngle");
  property("clipExtent");
  property("fitExtent");
  property("fitHeight");
  property("fitSize");
  property("fitWidth");
  property("scale");
  property("translate");
  property("precision");
  return gilbert.scale(249.5);
}

// node_modules/d3-geo-projection/src/gingery.js
function gingeryRaw(rho, n) {
  var k2 = 2 * pi / n, rho2 = rho * rho;
  function forward(lambda, phi) {
    var p = azimuthalEquidistantRaw(lambda, phi), x = p[0], y = p[1], r2 = x * x + y * y;
    if (r2 > rho2) {
      var r = sqrt(r2), theta = atan2(y, x), theta0 = k2 * round(theta / k2), alpha = theta - theta0, rhoCosAlpha = rho * cos(alpha), k_ = (rho * sin(alpha) - alpha * sin(rhoCosAlpha)) / (halfPi - rhoCosAlpha), s_ = gingeryLength(alpha, k_), e = (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);
      x = r;
      var i = 50, delta;
      do {
        x -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x) * e - r) / (s_(x) * e);
      } while (abs(delta) > epsilon && --i > 0);
      y = alpha * sin(x);
      if (x < halfPi) y -= k_ * (x - halfPi);
      var s = sin(theta0), c = cos(theta0);
      p[0] = x * c - y * s;
      p[1] = x * s + y * c;
    }
    return p;
  }
  forward.invert = function(x, y) {
    var r2 = x * x + y * y;
    if (r2 > rho2) {
      var r = sqrt(r2), theta = atan2(y, x), theta0 = k2 * round(theta / k2), dTheta = theta - theta0;
      x = r * cos(dTheta);
      y = r * sin(dTheta);
      var x_halfPi = x - halfPi, sinx = sin(x), alpha = y / sinx, delta = x < halfPi ? Infinity : 0, i = 10;
      while (true) {
        var rhosinAlpha = rho * sin(alpha), rhoCosAlpha = rho * cos(alpha), sinRhoCosAlpha = sin(rhoCosAlpha), halfPi_RhoCosAlpha = halfPi - rhoCosAlpha, k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha, s_ = gingeryLength(alpha, k_);
        if (abs(delta) < epsilon2 || !--i) break;
        alpha -= delta = (alpha * sinx - k_ * x_halfPi - y) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * cos(rhoCosAlpha) - sinRhoCosAlpha) - rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha));
      }
      r = rho + gingeryIntegrate(s_, rhoCosAlpha, x) * (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);
      theta = theta0 + alpha;
      x = r * cos(theta);
      y = r * sin(theta);
    }
    return azimuthalEquidistantRaw.invert(x, y);
  };
  return forward;
}
function gingeryLength(alpha, k2) {
  return function(x) {
    var y_ = alpha * cos(x);
    if (x < halfPi) y_ -= k2;
    return sqrt(1 + y_ * y_);
  };
}
function gingeryIntegrate(f, a, b) {
  var n = 50, h = (b - a) / n, s = f(a) + f(b);
  for (var i = 1, x = a; i < n; ++i) s += 2 * f(x += h);
  return s * 0.5 * h;
}
function gingery_default() {
  var n = 6, rho = 30 * radians, cRho = cos(rho), sRho = sin(rho), m = projectionMutator(gingeryRaw), p = m(rho, n), stream_ = p.stream, epsilon4 = 0.01, cr = -cos(epsilon4 * radians), sr = sin(epsilon4 * radians);
  p.radius = function(_) {
    if (!arguments.length) return rho * degrees;
    cRho = cos(rho = _ * radians);
    sRho = sin(rho);
    return m(rho, n);
  };
  p.lobes = function(_) {
    if (!arguments.length) return n;
    return m(rho, n = +_);
  };
  p.stream = function(stream) {
    var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart(), sphereStream.lineStart();
      for (var i = 0, delta = 2 * pi / n, phi = 0; i < n; ++i, phi -= delta) {
        sphereStream.point(atan2(sr * cos(phi), cr) * degrees, asin(sr * sin(phi)) * degrees);
        sphereStream.point(atan2(sRho * cos(phi - delta / 2), cRho) * degrees, asin(sRho * sin(phi - delta / 2)) * degrees);
      }
      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return p.rotate([90, -40]).scale(91.7095).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo-projection/src/ginzburgPolyconic.js
function ginzburgPolyconic_default(a, b, c, d, e, f, g, h) {
  if (arguments.length < 8) h = 0;
  function forward(lambda, phi) {
    if (!phi) return [a * lambda / pi, 0];
    var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), m = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin(xB / m) / pi;
    return [m * sin(alpha), phi * (1 + phi2 * h) + m * (1 - cos(alpha))];
  }
  forward.invert = function(x, y) {
    var lambda = pi * x / a, phi = y, deltaLambda, deltaPhi, i = 50;
    do {
      var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dAlphadLambda = asin(xB / m) / pi, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b + phi2 * (4 * c + phi2 * 6 * d)) * phi, dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos(alpha), sinAlpha = sin(alpha), mcosAlpha = m * cosAlpha, msinAlpha = m * sinAlpha, dAlphadPhi = lambda / pi * (1 / sqrt(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi) / m2, fx = msinAlpha - x, fy = phi * (1 + phi2 * h) + m - mcosAlpha - y, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator) break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
    return [lambda, phi];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/ginzburg4.js
var ginzburg4Raw = ginzburgPolyconic_default(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);
function ginzburg4_default() {
  return projection(ginzburg4Raw).scale(149.995);
}

// node_modules/d3-geo-projection/src/ginzburg5.js
var ginzburg5Raw = ginzburgPolyconic_default(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);
function ginzburg5_default() {
  return projection(ginzburg5Raw).scale(153.93);
}

// node_modules/d3-geo-projection/src/ginzburg6.js
var ginzburg6Raw = ginzburgPolyconic_default(5 / 6 * pi, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);
function ginzburg6_default() {
  return projection(ginzburg6Raw).scale(130.945);
}

// node_modules/d3-geo-projection/src/ginzburg8.js
function ginzburg8Raw(lambda, phi) {
  var lambda2 = lambda * lambda, phi2 = phi * phi;
  return [
    lambda * (1 - 0.162388 * phi2) * (0.87 - 952426e-9 * lambda2 * lambda2),
    phi * (1 + phi2 / 12)
  ];
}
ginzburg8Raw.invert = function(x, y) {
  var lambda = x, phi = y, i = 50, delta;
  do {
    var phi2 = phi * phi;
    phi -= delta = (phi * (1 + phi2 / 12) - y) / (1 + phi2 / 4);
  } while (abs(delta) > epsilon && --i > 0);
  i = 50;
  x /= 1 - 0.162388 * phi2;
  do {
    var lambda4 = (lambda4 = lambda * lambda) * lambda4;
    lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x) / (0.87 - 476213e-8 * lambda4);
  } while (abs(delta) > epsilon && --i > 0);
  return [lambda, phi];
};
function ginzburg8_default() {
  return projection(ginzburg8Raw).scale(131.747);
}

// node_modules/d3-geo-projection/src/ginzburg9.js
var ginzburg9Raw = ginzburgPolyconic_default(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);
function ginzburg9_default() {
  return projection(ginzburg9Raw).scale(131.087);
}

// node_modules/d3-geo-projection/src/square.js
function square_default(project) {
  var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];
  function projectSquare(lambda, phi) {
    var s = lambda > 0 ? -0.5 : 0.5, point = project(lambda + s * pi, phi);
    point[0] -= s * dx;
    return point;
  }
  if (project.invert) projectSquare.invert = function(x, y) {
    var s = x > 0 ? -0.5 : 0.5, location = project.invert(x + s * dx, y), lambda = location[0] - s * pi;
    if (lambda < -pi) lambda += 2 * pi;
    else if (lambda > pi) lambda -= 2 * pi;
    location[0] = lambda;
    return location;
  };
  return projectSquare;
}

// node_modules/d3-geo-projection/src/gringorten.js
function gringortenRaw(lambda, phi) {
  var sLambda = sign(lambda), sPhi = sign(phi), cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(sPhi * phi);
  lambda = abs(atan2(y, z));
  phi = asin(x);
  if (abs(lambda - halfPi) > epsilon) lambda %= halfPi;
  var point = gringortenHexadecant(lambda > pi / 4 ? halfPi - lambda : lambda, phi);
  if (lambda > pi / 4) z = point[0], point[0] = -point[1], point[1] = -z;
  return point[0] *= sLambda, point[1] *= -sPhi, point;
}
gringortenRaw.invert = function(x, y) {
  if (abs(x) > 1) x = sign(x) * 2 - x;
  if (abs(y) > 1) y = sign(y) * 2 - y;
  var sx = sign(x), sy = sign(y), x02 = -sx * x, y02 = -sy * y, t = y02 / x02 < 1, p = gringortenHexadecantInvert(t ? y02 : x02, t ? x02 : y02), lambda = p[0], phi = p[1], cosPhi = cos(phi);
  if (t) lambda = -halfPi - lambda;
  return [sx * (atan2(sin(lambda) * cosPhi, -sin(phi)) + pi), sy * asin(cos(lambda) * cosPhi)];
};
function gringortenHexadecant(lambda, phi) {
  if (phi === halfPi) return [0, 0];
  var sinPhi = sin(phi), r = sinPhi * sinPhi, r2 = r * r, j = 1 + r2, k2 = 1 + 3 * r2, q = 1 - r2, z = asin(1 / sqrt(j)), v = q + r * j * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * j, a = sqrt(a2), h = p * q, x, i;
  if (lambda === 0) return [0, -(h + r * a)];
  var cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * k2) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = q * dpdPhi - 2 * r * p * drdPhi, dra2dPhi = r * j * dp2dPhi + p2 * k2 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda1 = 4 * lambda / pi, delta;
  if (lambda > 0.222 * pi || phi < pi / 4 && lambda > 0.175 * pi) {
    x = (h + r * sqrt(a2 * (1 + r2) - h * h)) / (1 + r2);
    if (lambda > pi / 4) return [x, x];
    var x12 = x, x02 = 0.5 * x;
    x = 0.5 * (x02 + x12), i = 50;
    do {
      var g = sqrt(a2 - x * x), f = x * (zeta + mu * g) + nu * asin(x / a) - lambda1;
      if (!f) break;
      if (f < 0) x02 = x;
      else x12 = x;
      x = 0.5 * (x02 + x12);
    } while (abs(x12 - x02) > epsilon && --i > 0);
  } else {
    x = epsilon, i = 25;
    do {
      var x2 = x * x, g2 = sqrt(a2 - x2), zetaMug = zeta + mu * g2, f2 = x * zetaMug + nu * asin(x / a) - lambda1, df = zetaMug + (nu - mu * x2) / g2;
      x -= delta = g2 ? f2 / df : 0;
    } while (abs(delta) > epsilon && --i > 0);
  }
  return [x, -h - r * sqrt(a2 - x * x)];
}
function gringortenHexadecantInvert(x, y) {
  var x02 = 0, x12 = 1, r = 0.5, i = 50;
  while (true) {
    var r2 = r * r, sinPhi = sqrt(r), z = asin(1 / sqrt(1 + r2)), v = 1 - r2 + r * (1 + r2) * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * (1 + r2), h = p * (1 - r2), g2 = a2 - x * x, g = sqrt(g2), y02 = y + h + r * g;
    if (abs(x12 - x02) < epsilon2 || --i === 0 || y02 === 0) break;
    if (y02 > 0) x02 = r;
    else x12 = r;
    r = 0.5 * (x02 + x12);
  }
  if (!i) return null;
  var phi = asin(sinPhi), cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);
  return [pi / 4 * (x * (zeta + mu * g) + nu * asin(x / sqrt(a2))), phi];
}
function gringorten_default() {
  return projection(square_default(gringortenRaw)).scale(239.75);
}

// node_modules/d3-geo-projection/src/elliptic.js
function ellipticJi(u, v, m) {
  var a, b, c;
  if (!u) {
    b = ellipticJ(v, 1 - m);
    return [
      [0, b[0] / b[1]],
      [1 / b[1], 0],
      [b[2] / b[1], 0]
    ];
  }
  a = ellipticJ(u, m);
  if (!v) return [[a[0], 0], [a[1], 0], [a[2], 0]];
  b = ellipticJ(v, 1 - m);
  c = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
  return [
    [a[0] * b[2] / c, a[1] * a[2] * b[0] * b[1] / c],
    [a[1] * b[1] / c, -a[0] * a[2] * b[0] * b[2] / c],
    [a[2] * b[1] * b[2] / c, -m * a[0] * a[1] * b[0] / c]
  ];
}
function ellipticJ(u, m) {
  var ai, b, phi, t, twon;
  if (m < epsilon) {
    t = sin(u);
    b = cos(u);
    ai = m * (u - t * b) / 4;
    return [
      t - ai * b,
      b + ai * t,
      1 - m * t * t / 2,
      u - ai
    ];
  }
  if (m >= 1 - epsilon) {
    ai = (1 - m) / 4;
    b = cosh(u);
    t = tanh(u);
    phi = 1 / b;
    twon = b * sinh(u);
    return [
      t + ai * (twon - u) / (b * b),
      phi - ai * t * phi * (twon - u),
      phi + ai * t * phi * (twon + u),
      2 * atan(exp(u)) - halfPi + ai * (twon - u) / b
    ];
  }
  var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
  b = sqrt(1 - m);
  twon = 1;
  while (abs(c[i] / a[i]) > epsilon && i < 8) {
    ai = a[i++];
    c[i] = (ai - b) / 2;
    a[i] = (ai + b) / 2;
    b = sqrt(ai * b);
    twon *= 2;
  }
  phi = twon * a[i] * u;
  do {
    t = c[i] * sin(b = phi) / a[i];
    phi = (asin(t) + phi) / 2;
  } while (--i);
  return [sin(phi), t = cos(phi), t / cos(phi - b), phi];
}
function ellipticFi(phi, psi, m) {
  var r = abs(phi), i = abs(psi), sinhPsi = sinh(i);
  if (r) {
    var cscPhi = 1 / sin(r), cotPhi2 = 1 / (tan(r) * tan(r)), b = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m), c = (m - 1) * cotPhi2, cotLambda2 = (-b + sqrt(b * b - 4 * c)) / 2;
    return [
      ellipticF(atan(1 / sqrt(cotLambda2)), m) * sign(phi),
      ellipticF(atan(sqrt((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * sign(psi)
    ];
  }
  return [
    0,
    ellipticF(atan(sinhPsi), 1 - m) * sign(psi)
  ];
}
function ellipticF(phi, m) {
  if (!m) return phi;
  if (m === 1) return log(tan(phi / 2 + quarterPi));
  var a = 1, b = sqrt(1 - m), c = sqrt(m);
  for (var i = 0; abs(c) > epsilon; i++) {
    if (phi % pi) {
      var dPhi = atan(b * tan(phi) / a);
      if (dPhi < 0) dPhi += pi;
      phi += dPhi + ~~(phi / pi) * pi;
    } else phi += phi;
    c = (a + b) / 2;
    b = sqrt(a * b);
    c = ((a = c) - b) / 2;
  }
  return phi / (pow(2, i) * a);
}

// node_modules/d3-geo-projection/src/guyou.js
function guyouRaw(lambda, phi) {
  var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt(1 - k_ * k_), K3 = ellipticF(halfPi, k2 * k2), f = -1, psi = log(tan(pi / 4 + abs(phi) / 2)), r = exp(f * psi) / sqrt(k_), at = guyouComplexAtan(r * cos(f * lambda), r * sin(f * lambda)), t = ellipticFi(at[0], at[1], k2 * k2);
  return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K3 - t[0])];
}
function guyouComplexAtan(x, y) {
  var x2 = x * x, y_1 = y + 1, t = 1 - x2 - y * y;
  return [
    0.5 * ((x >= 0 ? halfPi : -halfPi) - atan2(t, 2 * x)),
    -0.25 * log(t * t + 4 * x2) + 0.5 * log(y_1 * y_1 + x2)
  ];
}
function guyouComplexDivide(a, b) {
  var denominator = b[0] * b[0] + b[1] * b[1];
  return [
    (a[0] * b[0] + a[1] * b[1]) / denominator,
    (a[1] * b[0] - a[0] * b[1]) / denominator
  ];
}
guyouRaw.invert = function(x, y) {
  var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt(1 - k_ * k_), K3 = ellipticF(halfPi, k2 * k2), f = -1, j = ellipticJi(0.5 * K3 - y, -x, k2 * k2), tn = guyouComplexDivide(j[0], j[1]), lambda = atan2(tn[1], tn[0]) / f;
  return [
    lambda,
    2 * atan(exp(0.5 / f * log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi
  ];
};
function guyou_default() {
  return projection(square_default(guyouRaw)).scale(151.496);
}

// node_modules/d3-geo-projection/src/hammerRetroazimuthal.js
function hammerRetroazimuthalRaw(phi02) {
  var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02), rotate = hammerRetroazimuthalRotation(phi02);
  rotate.invert = hammerRetroazimuthalRotation(-phi02);
  function forward(lambda, phi) {
    var p = rotate(lambda, phi);
    lambda = p[0], phi = p[1];
    var sinPhi = sin(phi), cosPhi = cos(phi), cosLambda = cos(lambda), z = acos(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda), sinz = sin(z), K3 = abs(sinz) > epsilon ? z / sinz : 1;
    return [
      K3 * cosPhi0 * sin(lambda),
      (abs(lambda) > halfPi ? K3 : -K3) * (sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)
    ];
  }
  forward.invert = function(x, y) {
    var rho = sqrt(x * x + y * y), sinz = -sin(rho), cosz = cos(rho), a = rho * cosz, b = -y * sinz, c = rho * sinPhi0, d = sqrt(a * a + b * b - c * c), phi = atan2(a * c + b * d, b * c - a * d), lambda = (rho > halfPi ? -1 : 1) * atan2(x * sinz, rho * cos(phi) * cosz + y * sin(phi) * sinz);
    return rotate.invert(lambda, phi);
  };
  return forward;
}
function hammerRetroazimuthalRotation(phi02) {
  var sinPhi0 = sin(phi02), cosPhi0 = cos(phi02);
  return function(lambda, phi) {
    var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi);
    return [
      atan2(y, x * cosPhi0 - z * sinPhi0),
      asin(z * cosPhi0 + x * sinPhi0)
    ];
  };
}
function hammerRetroazimuthal_default() {
  var phi02 = 0, m = projectionMutator(hammerRetroazimuthalRaw), p = m(phi02), rotate_ = p.rotate, stream_ = p.stream, circle = circle_default();
  p.parallel = function(_) {
    if (!arguments.length) return phi02 * degrees;
    var r = p.rotate();
    return m(phi02 = _ * radians).rotate(r);
  };
  p.rotate = function(_) {
    if (!arguments.length) return _ = rotate_.call(p), _[1] += phi02 * degrees, _;
    rotate_.call(p, [_[0], _[1] - phi02 * degrees]);
    circle.center([-_[0], -_[1]]);
    return p;
  };
  p.stream = function(stream) {
    stream = stream_(stream);
    stream.sphere = function() {
      stream.polygonStart();
      var epsilon4 = 0.01, ring = circle.radius(90 - epsilon4)().coordinates[0], n = ring.length - 1, i = -1, p2;
      stream.lineStart();
      while (++i < n) stream.point((p2 = ring[i])[0], p2[1]);
      stream.lineEnd();
      ring = circle.radius(90 + epsilon4)().coordinates[0];
      n = ring.length - 1;
      stream.lineStart();
      while (--i >= 0) stream.point((p2 = ring[i])[0], p2[1]);
      stream.lineEnd();
      stream.polygonEnd();
    };
    return stream;
  };
  return p.scale(79.4187).parallel(45).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo-projection/src/healpix.js
var K = 3;
var healpixParallel = asin(1 - 1 / K) * degrees;
var healpixLambert = cylindricalEqualAreaRaw(0);
function healpixRaw(H) {
  var phi02 = healpixParallel * radians, dx = collignonRaw(pi, phi02)[0] - collignonRaw(-pi, phi02)[0], y02 = healpixLambert(0, phi02)[1], y12 = collignonRaw(0, phi02)[1], dy1 = sqrtPi - y12, k2 = tau / H, w2 = 4 / tau, h = y02 + dy1 * dy1 * 4 / tau;
  function forward(lambda, phi) {
    var point, phi2 = abs(phi);
    if (phi2 > phi02) {
      var i = min(H - 1, max(0, floor((lambda + pi) / k2)));
      lambda += pi * (H - 1) / H - i * k2;
      point = collignonRaw(lambda, phi2);
      point[0] = point[0] * tau / dx - tau * (H - 1) / (2 * H) + i * tau / H;
      point[1] = y02 + (point[1] - y12) * 4 * dy1 / tau;
      if (phi < 0) point[1] = -point[1];
    } else {
      point = healpixLambert(lambda, phi);
    }
    point[0] *= w2, point[1] /= h;
    return point;
  }
  forward.invert = function(x, y) {
    x /= w2, y *= h;
    var y2 = abs(y);
    if (y2 > y02) {
      var i = min(H - 1, max(0, floor((x + pi) / k2)));
      x = (x + pi * (H - 1) / H - i * k2) * dx / tau;
      var point = collignonRaw.invert(x, 0.25 * (y2 - y02) * tau / dy1 + y12);
      point[0] -= pi * (H - 1) / H - i * k2;
      if (y < 0) point[1] = -point[1];
      return point;
    }
    return healpixLambert.invert(x, y);
  };
  return forward;
}
function sphereTop(x, i) {
  return [x, i & 1 ? 90 - epsilon : healpixParallel];
}
function sphereBottom(x, i) {
  return [x, i & 1 ? -90 + epsilon : -healpixParallel];
}
function sphereNudge(d) {
  return [d[0] * (1 - epsilon), d[1]];
}
function sphere(step) {
  var c = [].concat(
    range(-180, 180 + step / 2, step).map(sphereTop),
    range(180, -180 - step / 2, -step).map(sphereBottom)
  );
  return {
    type: "Polygon",
    coordinates: [step === 180 ? c.map(sphereNudge) : c]
  };
}
function healpix_default() {
  var H = 4, m = projectionMutator(healpixRaw), p = m(H), stream_ = p.stream;
  p.lobes = function(_) {
    return arguments.length ? m(H = +_) : H;
  };
  p.stream = function(stream) {
    var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);
    rotateStream.sphere = function() {
      stream_default(sphere(180 / H), sphereStream);
    };
    return rotateStream;
  };
  return p.scale(239.75);
}

// node_modules/d3-geo-projection/src/hill.js
function hillRaw(K3) {
  var L = 1 + K3, sinBt = sin(1 / L), Bt = asin(sinBt), A2 = 2 * sqrt(pi / (B2 = pi + 4 * Bt * L)), B2, rho0 = 0.5 * A2 * (L + sqrt(K3 * (2 + K3))), K22 = K3 * K3, L2 = L * L;
  function forward(lambda, phi) {
    var t = 1 - sin(phi), rho, omega;
    if (t && t < 2) {
      var theta = halfPi - phi, i = 25, delta;
      do {
        var sinTheta = sin(theta), cosTheta = cos(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta), C = 1 + L2 - 2 * L * cosTheta;
        theta -= delta = (theta - K22 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B2) / (2 * L * sinTheta * Bt_Bt1);
      } while (abs(delta) > epsilon2 && --i > 0);
      rho = A2 * sqrt(C);
      omega = lambda * Bt_Bt1 / pi;
    } else {
      rho = A2 * (K3 + t);
      omega = lambda * Bt / pi;
    }
    return [
      rho * sin(omega),
      rho0 - rho * cos(omega)
    ];
  }
  forward.invert = function(x, y) {
    var rho2 = x * x + (y -= rho0) * y, cosTheta = (1 + L2 - rho2 / (A2 * A2)) / (2 * L), theta = acos(cosTheta), sinTheta = sin(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta);
    return [
      asin(x / sqrt(rho2)) * pi / Bt_Bt1,
      asin(1 - 2 * (theta - K22 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B2)
    ];
  };
  return forward;
}
function hill_default() {
  var K3 = 1, m = projectionMutator(hillRaw), p = m(K3);
  p.ratio = function(_) {
    return arguments.length ? m(K3 = +_) : K3;
  };
  return p.scale(167.774).center([0, 18.67]);
}

// node_modules/d3-geo-projection/src/sinuMollweide.js
var sinuMollweidePhi = 0.7109889596207567;
var sinuMollweideY = 0.0528035274542;
function sinuMollweideRaw(lambda, phi) {
  return phi > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
}
sinuMollweideRaw.invert = function(x, y) {
  return y > -sinuMollweidePhi ? mollweideRaw.invert(x, y - sinuMollweideY) : sinusoidalRaw.invert(x, y);
};
function sinuMollweide_default() {
  return projection(sinuMollweideRaw).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
}

// node_modules/d3-geo-projection/src/homolosine.js
function homolosineRaw(lambda, phi) {
  return abs(phi) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] -= phi > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
}
homolosineRaw.invert = function(x, y) {
  return abs(y) > sinuMollweidePhi ? mollweideRaw.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x, y);
};
function homolosine_default() {
  return projection(homolosineRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/hufnagel.js
function hufnagelRaw(a, b, psiMax, ratio) {
  var k2 = sqrt(
    4 * pi / (2 * psiMax + (1 + a - b / 2) * sin(2 * psiMax) + (a + b) / 2 * sin(4 * psiMax) + b / 2 * sin(6 * psiMax))
  ), c = sqrt(
    ratio * sin(psiMax) * sqrt((1 + a * cos(2 * psiMax) + b * cos(4 * psiMax)) / (1 + a + b))
  ), M = psiMax * mapping(1);
  function radius(psi) {
    return sqrt(1 + a * cos(2 * psi) + b * cos(4 * psi));
  }
  function mapping(t) {
    var psi = t * psiMax;
    return (2 * psi + (1 + a - b / 2) * sin(2 * psi) + (a + b) / 2 * sin(4 * psi) + b / 2 * sin(6 * psi)) / psiMax;
  }
  function inversemapping(psi) {
    return radius(psi) * sin(psi);
  }
  var forward = function(lambda, phi) {
    var psi = psiMax * solve(mapping, M * sin(phi) / psiMax, phi / pi);
    if (isNaN(psi)) psi = psiMax * sign(phi);
    var kr = k2 * radius(psi);
    return [kr * c * lambda / pi * cos(psi), kr / c * sin(psi)];
  };
  forward.invert = function(x, y) {
    var psi = solve(inversemapping, y * c / k2);
    return [
      x * pi / (cos(psi) * k2 * c * radius(psi)),
      asin(psiMax * mapping(psi / psiMax) / M)
    ];
  };
  if (psiMax === 0) {
    k2 = sqrt(ratio / pi);
    forward = function(lambda, phi) {
      return [lambda * k2, sin(phi) / k2];
    };
    forward.invert = function(x, y) {
      return [x / k2, asin(y * k2)];
    };
  }
  return forward;
}
function hufnagel_default() {
  var a = 1, b = 0, psiMax = 45 * radians, ratio = 2, mutate = projectionMutator(hufnagelRaw), projection2 = mutate(a, b, psiMax, ratio);
  projection2.a = function(_) {
    return arguments.length ? mutate(a = +_, b, psiMax, ratio) : a;
  };
  projection2.b = function(_) {
    return arguments.length ? mutate(a, b = +_, psiMax, ratio) : b;
  };
  projection2.psiMax = function(_) {
    return arguments.length ? mutate(a, b, psiMax = +_ * radians, ratio) : psiMax * degrees;
  };
  projection2.ratio = function(_) {
    return arguments.length ? mutate(a, b, psiMax, ratio = +_) : ratio;
  };
  return projection2.scale(180.739);
}

// node_modules/d3-geo-projection/src/integrate.js
function adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, depth, state) {
  if (state.nanEncountered) {
    return NaN;
  }
  var h, f1, f2, sl, sr, s2, m, V1, V2, err;
  h = b - a;
  f1 = f(a + h * 0.25);
  f2 = f(b - h * 0.25);
  if (isNaN(f1)) {
    state.nanEncountered = true;
    return;
  }
  if (isNaN(f2)) {
    state.nanEncountered = true;
    return;
  }
  sl = h * (fa + 4 * f1 + fm) / 12;
  sr = h * (fm + 4 * f2 + fb) / 12;
  s2 = sl + sr;
  err = (s2 - V0) / 15;
  if (depth > maxdepth) {
    state.maxDepthCount++;
    return s2 + err;
  } else if (Math.abs(err) < tol) {
    return s2 + err;
  } else {
    m = a + h * 0.5;
    V1 = adsimp(f, a, m, fa, f1, fm, sl, tol * 0.5, maxdepth, depth + 1, state);
    if (isNaN(V1)) {
      state.nanEncountered = true;
      return NaN;
    }
    V2 = adsimp(f, m, b, fm, f2, fb, sr, tol * 0.5, maxdepth, depth + 1, state);
    if (isNaN(V2)) {
      state.nanEncountered = true;
      return NaN;
    }
    return V1 + V2;
  }
}
function integrate(f, a, b, tol, maxdepth) {
  var state = {
    maxDepthCount: 0,
    nanEncountered: false
  };
  if (tol === void 0) {
    tol = 1e-8;
  }
  if (maxdepth === void 0) {
    maxdepth = 20;
  }
  var fa = f(a);
  var fm = f(0.5 * (a + b));
  var fb = f(b);
  var V0 = (fa + 4 * fm + fb) * (b - a) / 6;
  var result = adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, 1, state);
  return result;
}

// node_modules/d3-geo-projection/src/hyperelliptical.js
function hyperellipticalRaw(alpha, k2, gamma) {
  function elliptic(f) {
    return alpha + (1 - alpha) * pow(1 - pow(f, k2), 1 / k2);
  }
  function z(f) {
    return integrate(elliptic, 0, f, 1e-4);
  }
  var G = 1 / z(1), n = 1e3, m = (1 + 1e-8) * G, approx = [];
  for (var i = 0; i <= n; i++)
    approx.push(z(i / n) * m);
  function Y(sinphi) {
    var rmin = 0, rmax = n, r = n >> 1;
    do {
      if (approx[r] > sinphi) rmax = r;
      else rmin = r;
      r = rmin + rmax >> 1;
    } while (r > rmin);
    var u = approx[r + 1] - approx[r];
    if (u) u = (sinphi - approx[r + 1]) / u;
    return (r + 1 + u) / n;
  }
  var ratio = 2 * Y(1) / pi * G / gamma;
  var forward = function(lambda, phi) {
    var y = Y(abs(sin(phi))), x = elliptic(y) * lambda;
    y /= ratio;
    return [x, phi >= 0 ? y : -y];
  };
  forward.invert = function(x, y) {
    var phi;
    y *= ratio;
    if (abs(y) < 1) phi = sign(y) * asin(z(abs(y)) * G);
    return [x / elliptic(abs(y)), phi];
  };
  return forward;
}
function hyperelliptical_default() {
  var alpha = 0, k2 = 2.5, gamma = 1.183136, m = projectionMutator(hyperellipticalRaw), p = m(alpha, k2, gamma);
  p.alpha = function(_) {
    return arguments.length ? m(alpha = +_, k2, gamma) : alpha;
  };
  p.k = function(_) {
    return arguments.length ? m(alpha, k2 = +_, gamma) : k2;
  };
  p.gamma = function(_) {
    return arguments.length ? m(alpha, k2, gamma = +_) : gamma;
  };
  return p.scale(152.63);
}

// node_modules/d3-geo-projection/src/interrupted/index.js
function pointEqual(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
}
function interpolateLine(coordinates, m) {
  var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];
  while (++i < n) {
    p1 = coordinates[i];
    dx = (p1[0] - p0[0]) / m;
    dy = (p1[1] - p0[1]) / m;
    for (var j = 0; j < m; ++j) resampled.push([p0[0] + j * dx, p0[1] + j * dy]);
    p0 = p1;
  }
  resampled.push(p1);
  return resampled;
}
function interpolateSphere(lobes8) {
  var coordinates = [], lobe, lambda0, phi02, phi1, lambda2, phi2, i, n = lobes8[0].length;
  for (i = 0; i < n; ++i) {
    lobe = lobes8[0][i];
    lambda0 = lobe[0][0], phi02 = lobe[0][1], phi1 = lobe[1][1];
    lambda2 = lobe[2][0], phi2 = lobe[2][1];
    coordinates.push(interpolateLine([
      [lambda0 + epsilon, phi02 + epsilon],
      [lambda0 + epsilon, phi1 - epsilon],
      [lambda2 - epsilon, phi1 - epsilon],
      [lambda2 - epsilon, phi2 + epsilon]
    ], 30));
  }
  for (i = lobes8[1].length - 1; i >= 0; --i) {
    lobe = lobes8[1][i];
    lambda0 = lobe[0][0], phi02 = lobe[0][1], phi1 = lobe[1][1];
    lambda2 = lobe[2][0], phi2 = lobe[2][1];
    coordinates.push(interpolateLine([
      [lambda2 - epsilon, phi2 - epsilon],
      [lambda2 - epsilon, phi1 + epsilon],
      [lambda0 + epsilon, phi1 + epsilon],
      [lambda0 + epsilon, phi02 - epsilon]
    ], 30));
  }
  return {
    type: "Polygon",
    coordinates: [merge(coordinates)]
  };
}
function interrupted_default(project, lobes8, inverse2) {
  var sphere2, bounds;
  function forward(lambda, phi) {
    var sign2 = phi < 0 ? -1 : 1, lobe = lobes8[+(phi < 0)];
    for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i) ;
    var p2 = project(lambda - lobe[i][1][0], phi);
    p2[0] += project(lobe[i][1][0], sign2 * phi > sign2 * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];
    return p2;
  }
  if (inverse2) {
    forward.invert = inverse2(forward);
  } else if (project.invert) {
    forward.invert = function(x, y) {
      var bound = bounds[+(y < 0)], lobe = lobes8[+(y < 0)];
      for (var i = 0, n = bound.length; i < n; ++i) {
        var b = bound[i];
        if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
          var p2 = project.invert(x - project(lobe[i][1][0], 0)[0], y);
          p2[0] += lobe[i][1][0];
          return pointEqual(forward(p2[0], p2[1]), [x, y]) ? p2 : null;
        }
      }
    };
  }
  var p = projection(forward), stream_ = p.stream;
  p.stream = function(stream) {
    var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);
    rotateStream.sphere = function() {
      stream_default(sphere2, sphereStream);
    };
    return rotateStream;
  };
  p.lobes = function(_) {
    if (!arguments.length) return lobes8.map(function(lobe) {
      return lobe.map(function(l) {
        return [
          [l[0][0] * degrees, l[0][1] * degrees],
          [l[1][0] * degrees, l[1][1] * degrees],
          [l[2][0] * degrees, l[2][1] * degrees]
        ];
      });
    });
    sphere2 = interpolateSphere(_);
    lobes8 = _.map(function(lobe) {
      return lobe.map(function(l) {
        return [
          [l[0][0] * radians, l[0][1] * radians],
          [l[1][0] * radians, l[1][1] * radians],
          [l[2][0] * radians, l[2][1] * radians]
        ];
      });
    });
    bounds = lobes8.map(function(lobe) {
      return lobe.map(function(l) {
        var x02 = project(l[0][0], l[0][1])[0], x12 = project(l[2][0], l[2][1])[0], y02 = project(l[1][0], l[0][1])[1], y12 = project(l[1][0], l[1][1])[1], t;
        if (y02 > y12) t = y02, y02 = y12, y12 = t;
        return [[x02, y02], [x12, y12]];
      });
    });
    return p;
  };
  if (lobes8 != null) p.lobes(lobes8);
  return p;
}

// node_modules/d3-geo-projection/src/interrupted/boggs.js
var lobes = [[
  // northern hemisphere
  [[-180, 0], [-100, 90], [-40, 0]],
  [[-40, 0], [30, 90], [180, 0]]
], [
  // southern hemisphere
  [[-180, 0], [-160, -90], [-100, 0]],
  [[-100, 0], [-60, -90], [-20, 0]],
  [[-20, 0], [20, -90], [80, 0]],
  [[80, 0], [140, -90], [180, 0]]
]];
function boggs_default2() {
  return interrupted_default(boggsRaw, lobes).scale(160.857);
}

// node_modules/d3-geo-projection/src/interrupted/homolosine.js
var lobes2 = [[
  // northern hemisphere
  [[-180, 0], [-100, 90], [-40, 0]],
  [[-40, 0], [30, 90], [180, 0]]
], [
  // southern hemisphere
  [[-180, 0], [-160, -90], [-100, 0]],
  [[-100, 0], [-60, -90], [-20, 0]],
  [[-20, 0], [20, -90], [80, 0]],
  [[80, 0], [140, -90], [180, 0]]
]];
function homolosine_default2() {
  return interrupted_default(homolosineRaw, lobes2).scale(152.63);
}

// node_modules/d3-geo-projection/src/interrupted/mollweide.js
var lobes3 = [[
  // northern hemisphere
  [[-180, 0], [-100, 90], [-40, 0]],
  [[-40, 0], [30, 90], [180, 0]]
], [
  // southern hemisphere
  [[-180, 0], [-160, -90], [-100, 0]],
  [[-100, 0], [-60, -90], [-20, 0]],
  [[-20, 0], [20, -90], [80, 0]],
  [[80, 0], [140, -90], [180, 0]]
]];
function mollweide_default2() {
  return interrupted_default(mollweideRaw, lobes3).scale(169.529);
}

// node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js
var lobes4 = [[
  // northern hemisphere
  [[-180, 0], [-90, 90], [0, 0]],
  [[0, 0], [90, 90], [180, 0]]
], [
  // southern hemisphere
  [[-180, 0], [-90, -90], [0, 0]],
  [[0, 0], [90, -90], [180, 0]]
]];
function mollweideHemispheres_default() {
  return interrupted_default(mollweideRaw, lobes4).scale(169.529).rotate([20, 0]);
}

// node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js
var lobes5 = [[
  // northern hemisphere
  [[-180, 35], [-30, 90], [0, 35]],
  [[0, 35], [30, 90], [180, 35]]
], [
  // southern hemisphere
  [[-180, -10], [-102, -90], [-65, -10]],
  [[-65, -10], [5, -90], [77, -10]],
  [[77, -10], [103, -90], [180, -10]]
]];
function sinuMollweide_default2() {
  return interrupted_default(sinuMollweideRaw, lobes5, solve2d).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
}

// node_modules/d3-geo-projection/src/interrupted/sinusoidal.js
var lobes6 = [[
  // northern hemisphere
  [[-180, 0], [-110, 90], [-40, 0]],
  [[-40, 0], [0, 90], [40, 0]],
  [[40, 0], [110, 90], [180, 0]]
], [
  // southern hemisphere
  [[-180, 0], [-110, -90], [-40, 0]],
  [[-40, 0], [0, -90], [40, 0]],
  [[40, 0], [110, -90], [180, 0]]
]];
function sinusoidal_default2() {
  return interrupted_default(sinusoidalRaw, lobes6).scale(152.63).rotate([-20, 0]);
}

// node_modules/d3-geo-projection/src/kavrayskiy7.js
function kavrayskiy7Raw(lambda, phi) {
  return [3 / tau * lambda * sqrt(pi * pi / 3 - phi * phi), phi];
}
kavrayskiy7Raw.invert = function(x, y) {
  return [tau / 3 * x / sqrt(pi * pi / 3 - y * y), y];
};
function kavrayskiy7_default() {
  return projection(kavrayskiy7Raw).scale(158.837);
}

// node_modules/d3-geo-projection/src/lagrange.js
function lagrangeRaw(n) {
  function forward(lambda, phi) {
    if (abs(abs(phi) - halfPi) < epsilon) return [0, phi < 0 ? -2 : 2];
    var sinPhi = sin(phi), v = pow((1 + sinPhi) / (1 - sinPhi), n / 2), c = 0.5 * (v + 1 / v) + cos(lambda *= n);
    return [
      2 * sin(lambda) / c,
      (v - 1 / v) / c
    ];
  }
  forward.invert = function(x, y) {
    var y02 = abs(y);
    if (abs(y02 - 2) < epsilon) return x ? null : [0, sign(y) * halfPi];
    if (y02 > 2) return null;
    x /= 2, y /= 2;
    var x2 = x * x, y2 = y * y, t = 2 * y / (1 + x2 + y2);
    t = pow((1 + t) / (1 - t), 1 / n);
    return [
      atan2(2 * x, 1 - x2 - y2) / n,
      asin((t - 1) / (t + 1))
    ];
  };
  return forward;
}
function lagrange_default() {
  var n = 0.5, m = projectionMutator(lagrangeRaw), p = m(n);
  p.spacing = function(_) {
    return arguments.length ? m(n = +_) : n;
  };
  return p.scale(124.75);
}

// node_modules/d3-geo-projection/src/larrivee.js
var pi_sqrt2 = pi / sqrt2;
function larriveeRaw(lambda, phi) {
  return [
    lambda * (1 + sqrt(cos(phi))) / 2,
    phi / (cos(phi / 2) * cos(lambda / 6))
  ];
}
larriveeRaw.invert = function(x, y) {
  var x02 = abs(x), y02 = abs(y), lambda = epsilon, phi = halfPi;
  if (y02 < pi_sqrt2) phi *= y02 / pi_sqrt2;
  else lambda += 6 * acos(pi_sqrt2 / y02);
  for (var i = 0; i < 25; i++) {
    var sinPhi = sin(phi), sqrtcosPhi = sqrt(cos(phi)), sinPhi_2 = sin(phi / 2), cosPhi_2 = cos(phi / 2), sinLambda_6 = sin(lambda / 6), cosLambda_6 = cos(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x02, f1 = phi / (cosPhi_2 * cosLambda_6) - y02, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
    phi -= dPhi;
    lambda -= dLambda;
    if (abs(dPhi) < epsilon && abs(dLambda) < epsilon) break;
  }
  return [x < 0 ? -lambda : lambda, y < 0 ? -phi : phi];
};
function larrivee_default() {
  return projection(larriveeRaw).scale(97.2672);
}

// node_modules/d3-geo-projection/src/laskowski.js
function laskowskiRaw(lambda, phi) {
  var lambda2 = lambda * lambda, phi2 = phi * phi;
  return [
    lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)),
    phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032))
  ];
}
laskowskiRaw.invert = function(x, y) {
  var lambda = sign(x) * pi, phi = y / 2, i = 50;
  do {
    var lambda2 = lambda * lambda, phi2 = phi * phi, lambdaPhi = lambda * phi, fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x, fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y, deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda2 + 2 * -0.02855 * phi2), deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 199025e-9 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda, phi -= deltaPhi;
  } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);
  return i && [lambda, phi];
};
function laskowski_default() {
  return projection(laskowskiRaw).scale(139.98);
}

// node_modules/d3-geo-projection/src/littrow.js
function littrowRaw(lambda, phi) {
  return [
    sin(lambda) / cos(phi),
    tan(phi) * cos(lambda)
  ];
}
littrowRaw.invert = function(x, y) {
  var x2 = x * x, y2 = y * y, y2_1 = y2 + 1, x2_y2_1 = x2 + y2_1, cosPhi = x ? sqrt1_2 * sqrt((x2_y2_1 - sqrt(x2_y2_1 * x2_y2_1 - 4 * x2)) / x2) : 1 / sqrt(y2_1);
  return [
    asin(x * cosPhi),
    sign(y) * acos(cosPhi)
  ];
};
function littrow_default() {
  return projection(littrowRaw).scale(144.049).clipAngle(90 - 1e-3);
}

// node_modules/d3-geo-projection/src/loximuthal.js
function loximuthalRaw(phi02) {
  var cosPhi0 = cos(phi02), tanPhi0 = tan(quarterPi + phi02 / 2);
  function forward(lambda, phi) {
    var y = phi - phi02, x = abs(y) < epsilon ? lambda * cosPhi0 : abs(x = quarterPi + phi / 2) < epsilon || abs(abs(x) - halfPi) < epsilon ? 0 : lambda * y / log(tan(x) / tanPhi0);
    return [x, y];
  }
  forward.invert = function(x, y) {
    var lambda, phi = y + phi02;
    return [
      abs(y) < epsilon ? x / cosPhi0 : abs(lambda = quarterPi + phi / 2) < epsilon || abs(abs(lambda) - halfPi) < epsilon ? 0 : x * log(tan(lambda) / tanPhi0) / y,
      phi
    ];
  };
  return forward;
}
function loximuthal_default() {
  return parallel1_default(loximuthalRaw).parallel(40).scale(158.837);
}

// node_modules/d3-geo-projection/src/miller.js
function millerRaw(lambda, phi) {
  return [lambda, 1.25 * log(tan(quarterPi + 0.4 * phi))];
}
millerRaw.invert = function(x, y) {
  return [x, 2.5 * atan(exp(0.8 * y)) - 0.625 * pi];
};
function miller_default() {
  return projection(millerRaw).scale(108.318);
}

// node_modules/d3-geo-projection/src/modifiedStereographic.js
function modifiedStereographicRaw(C) {
  var m = C.length - 1;
  function forward(lambda, phi) {
    var cosPhi = cos(phi), k2 = 2 / (1 + cosPhi * cos(lambda)), zr = k2 * cosPhi * sin(lambda), zi = k2 * sin(phi), i = m, w2 = C[i], ar = w2[0], ai = w2[1], t;
    while (--i >= 0) {
      w2 = C[i];
      ar = w2[0] + zr * (t = ar) - zi * ai;
      ai = w2[1] + zr * ai + zi * t;
    }
    ar = zr * (t = ar) - zi * ai;
    ai = zr * ai + zi * t;
    return [ar, ai];
  }
  forward.invert = function(x, y) {
    var i = 20, zr = x, zi = y;
    do {
      var j = m, w2 = C[j], ar = w2[0], ai = w2[1], br = 0, bi = 0, t;
      while (--j >= 0) {
        w2 = C[j];
        br = ar + zr * (t = br) - zi * bi;
        bi = ai + zr * bi + zi * t;
        ar = w2[0] + zr * (t = ar) - zi * ai;
        ai = w2[1] + zr * ai + zi * t;
      }
      br = ar + zr * (t = br) - zi * bi;
      bi = ai + zr * bi + zi * t;
      ar = zr * (t = ar) - zi * ai - x;
      ai = zr * ai + zi * t - y;
      var denominator = br * br + bi * bi, deltar, deltai;
      zr -= deltar = (ar * br + ai * bi) / denominator;
      zi -= deltai = (ai * br - ar * bi) / denominator;
    } while (abs(deltar) + abs(deltai) > epsilon * epsilon && --i > 0);
    if (i) {
      var rho = sqrt(zr * zr + zi * zi), c = 2 * atan(rho * 0.5), sinc = sin(c);
      return [atan2(zr * sinc, rho * cos(c)), rho ? asin(zi * sinc / rho) : 0];
    }
  };
  return forward;
}
var alaska = [[0.9972523, 0], [52513e-7, -41175e-7], [74606e-7, 48125e-7], [-0.0153783, -0.1968253], [0.0636871, -0.1408027], [0.3660976, -0.2937382]];
var gs48 = [[0.98879, 0], [0, 0], [-0.050909, 0], [0, 0], [0.075528, 0]];
var gs50 = [[0.984299, 0], [0.0211642, 37608e-7], [-0.1036018, -0.0575102], [-0.0329095, -0.0320119], [0.0499471, 0.1223335], [0.026046, 0.0899805], [7388e-7, -0.1435792], [75848e-7, -0.1334108], [-0.0216473, 0.0776645], [-0.0225161, 0.0853673]];
var miller = [[0.9245, 0], [0, 0], [0.01943, 0]];
var lee = [[0.721316, 0], [0, 0], [-881625e-8, -617325e-8]];
function modifiedStereographicAlaska() {
  return modifiedStereographic(alaska, [152, -64]).scale(1400).center([-160.908, 62.4864]).clipAngle(30).angle(7.8);
}
function modifiedStereographicGs48() {
  return modifiedStereographic(gs48, [95, -38]).scale(1e3).clipAngle(55).center([-96.5563, 38.8675]);
}
function modifiedStereographicGs50() {
  return modifiedStereographic(gs50, [120, -45]).scale(359.513).clipAngle(55).center([-117.474, 53.0628]);
}
function modifiedStereographicMiller() {
  return modifiedStereographic(miller, [-20, -18]).scale(209.091).center([20, 16.7214]).clipAngle(82);
}
function modifiedStereographicLee() {
  return modifiedStereographic(lee, [165, 10]).scale(250).clipAngle(130).center([-165, -10]);
}
function modifiedStereographic(coefficients, rotate) {
  var p = projection(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90), r = rotation_default(rotate), center = p.center;
  delete p.rotate;
  p.center = function(_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };
  return p;
}

// node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js
var sqrt6 = sqrt(6);
var sqrt7 = sqrt(7);
function mtFlatPolarParabolicRaw(lambda, phi) {
  var theta = asin(7 * sin(phi) / (3 * sqrt6));
  return [
    sqrt6 * lambda * (2 * cos(2 * theta / 3) - 1) / sqrt7,
    9 * sin(theta / 3) / sqrt7
  ];
}
mtFlatPolarParabolicRaw.invert = function(x, y) {
  var theta = 3 * asin(y * sqrt7 / 9);
  return [
    x * sqrt7 / (sqrt6 * (2 * cos(2 * theta / 3) - 1)),
    asin(sin(theta) * 3 * sqrt6 / 7)
  ];
};
function mtFlatPolarParabolic_default() {
  return projection(mtFlatPolarParabolicRaw).scale(164.859);
}

// node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js
function mtFlatPolarQuarticRaw(lambda, phi) {
  var k2 = (1 + sqrt1_2) * sin(phi), theta = phi;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (sin(theta / 2) + sin(theta) - k2) / (0.5 * cos(theta / 2) + cos(theta));
    if (abs(delta) < epsilon) break;
  }
  return [
    lambda * (1 + 2 * cos(theta) / cos(theta / 2)) / (3 * sqrt2),
    2 * sqrt(3) * sin(theta / 2) / sqrt(2 + sqrt2)
  ];
}
mtFlatPolarQuarticRaw.invert = function(x, y) {
  var sinTheta_2 = y * sqrt(2 + sqrt2) / (2 * sqrt(3)), theta = 2 * asin(sinTheta_2);
  return [
    3 * sqrt2 * x / (1 + 2 * cos(theta) / cos(theta / 2)),
    asin((sinTheta_2 + sin(theta)) / (1 + sqrt1_2))
  ];
};
function mtFlatPolarQuartic_default() {
  return projection(mtFlatPolarQuarticRaw).scale(188.209);
}

// node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js
function mtFlatPolarSinusoidalRaw(lambda, phi) {
  var A2 = sqrt(6 / (4 + pi)), k2 = (1 + pi / 4) * sin(phi), theta = phi / 2;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (theta / 2 + sin(theta) - k2) / (0.5 + cos(theta));
    if (abs(delta) < epsilon) break;
  }
  return [
    A2 * (0.5 + cos(theta)) * lambda / 1.5,
    A2 * theta
  ];
}
mtFlatPolarSinusoidalRaw.invert = function(x, y) {
  var A2 = sqrt(6 / (4 + pi)), theta = y / A2;
  if (abs(abs(theta) - halfPi) < epsilon) theta = theta < 0 ? -halfPi : halfPi;
  return [
    1.5 * x / (A2 * (0.5 + cos(theta))),
    asin((theta / 2 + sin(theta)) / (1 + pi / 4))
  ];
};
function mtFlatPolarSinusoidal_default() {
  return projection(mtFlatPolarSinusoidalRaw).scale(166.518);
}

// node_modules/d3-geo-projection/src/naturalEarth2.js
function naturalEarth2Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2, phi6 = phi2 * phi4;
  return [
    lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4))
  ];
}
naturalEarth2Raw.invert = function(x, y) {
  var phi = y, i = 25, delta, phi2, phi4, phi6;
  do {
    phi2 = phi * phi;
    phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4)) - y) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi2 + 13 * -396e-5 * phi4));
  } while (abs(delta) > epsilon2 && --i > 0);
  phi2 = phi * phi;
  phi4 = phi2 * phi2;
  phi6 = phi2 * phi4;
  return [
    x / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi
  ];
};
function naturalEarth2_default() {
  return projection(naturalEarth2Raw).scale(175.295);
}

// node_modules/d3-geo-projection/src/nellHammer.js
function nellHammerRaw(lambda, phi) {
  return [
    lambda * (1 + cos(phi)) / 2,
    2 * (phi - tan(phi / 2))
  ];
}
nellHammerRaw.invert = function(x, y) {
  var p = y / 2;
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; ++i) {
    var c = cos(y / 2);
    y -= delta = (y - tan(y / 2) - p) / (1 - 0.5 / (c * c));
  }
  return [
    2 * x / (1 + cos(y)),
    y
  ];
};
function nellHammer_default() {
  return projection(nellHammerRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/interrupted/quarticAuthalic.js
var lobes7 = [[
  // northern hemisphere
  [[-180, 0], [-90, 90], [0, 0]],
  [[0, 0], [90, 90], [180, 0]]
], [
  // southern hemisphere
  [[-180, 0], [-90, -90], [0, 0]],
  [[0, 0], [90, -90], [180, 0]]
]];
function quarticAuthalic_default() {
  return interrupted_default(hammerRaw(Infinity), lobes7).rotate([20, 0]).scale(152.63);
}

// node_modules/d3-geo-projection/src/nicolosi.js
function nicolosiRaw(lambda, phi) {
  var sinPhi = sin(phi), q = cos(phi), s = sign(lambda);
  if (lambda === 0 || abs(phi) === halfPi) return [0, phi];
  else if (phi === 0) return [lambda, 0];
  else if (abs(lambda) === halfPi) return [lambda * q, halfPi * sinPhi];
  var b = pi / (2 * lambda) - 2 * lambda / pi, c = 2 * phi / pi, d = (1 - c * c) / (sinPhi - c);
  var b2 = b * b, d2 = d * d, b2d2 = 1 + b2 / d2, d2b2 = 1 + d2 / b2;
  var M = (b * sinPhi / d - b / 2) / b2d2, N = (d2 * sinPhi / b2 + d / 2) / d2b2, m = M * M + q * q / b2d2, n = N * N - (d2 * sinPhi * sinPhi / b2 + d * sinPhi - 1) / d2b2;
  return [
    halfPi * (M + sqrt(m) * s),
    halfPi * (N + sqrt(n < 0 ? 0 : n) * sign(-phi * b) * s)
  ];
}
nicolosiRaw.invert = function(x, y) {
  x /= halfPi;
  y /= halfPi;
  var x2 = x * x, y2 = y * y, x2y2 = x2 + y2, pi2 = pi * pi;
  return [
    x ? (x2y2 - 1 + sqrt((1 - x2y2) * (1 - x2y2) + 4 * x2)) / (2 * x) * halfPi : 0,
    solve(function(phi) {
      return x2y2 * (pi * sin(phi) - 2 * phi) * pi + 4 * phi * phi * (y - sin(phi)) + 2 * pi * phi - pi2 * y;
    }, 0)
  ];
};
function nicolosi_default() {
  return projection(nicolosiRaw).scale(127.267);
}

// node_modules/d3-geo-projection/src/patterson.js
var pattersonK1 = 1.0148;
var pattersonK2 = 0.23185;
var pattersonK3 = -0.14499;
var pattersonK4 = 0.02406;
var pattersonC1 = pattersonK1;
var pattersonC2 = 5 * pattersonK2;
var pattersonC3 = 7 * pattersonK3;
var pattersonC4 = 9 * pattersonK4;
var pattersonYmax = 1.790857183;
function pattersonRaw(lambda, phi) {
  var phi2 = phi * phi;
  return [
    lambda,
    phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))
  ];
}
pattersonRaw.invert = function(x, y) {
  if (y > pattersonYmax) y = pattersonYmax;
  else if (y < -pattersonYmax) y = -pattersonYmax;
  var yc = y, delta;
  do {
    var y2 = yc * yc;
    yc -= delta = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
  } while (abs(delta) > epsilon);
  return [x, yc];
};
function patterson_default() {
  return projection(pattersonRaw).scale(139.319);
}

// node_modules/d3-geo-projection/src/polyconic.js
function polyconicRaw(lambda, phi) {
  if (abs(phi) < epsilon) return [lambda, 0];
  var tanPhi = tan(phi), k2 = lambda * sin(phi);
  return [
    sin(k2) / tanPhi,
    phi + (1 - cos(k2)) / tanPhi
  ];
}
polyconicRaw.invert = function(x, y) {
  if (abs(y) < epsilon) return [x, 0];
  var k2 = x * x + y * y, phi = y * 0.5, i = 10, delta;
  do {
    var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k2 - 2 * y * phi + phi * phi;
    phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
  } while (abs(delta) > epsilon && --i > 0);
  tanPhi = tan(phi);
  return [
    (abs(y) < abs(phi + 1 / tanPhi) ? asin(x * tanPhi) : sign(y) * sign(x) * (acos(abs(x * tanPhi)) + halfPi)) / sin(phi),
    phi
  ];
};
function polyconic_default() {
  return projection(polyconicRaw).scale(103.74);
}

// node_modules/d3-geo-projection/src/polyhedral/matrix.js
function matrix_default(a, b) {
  var u = subtract(a[1], a[0]), v = subtract(b[1], b[0]), phi = angle2(u, v), s = length(u) / length(v);
  return multiply([
    1,
    0,
    a[0][0],
    0,
    1,
    a[0][1]
  ], multiply([
    s,
    0,
    0,
    0,
    s,
    0
  ], multiply([
    cos(phi),
    sin(phi),
    0,
    -sin(phi),
    cos(phi),
    0
  ], [
    1,
    0,
    -b[0][0],
    0,
    1,
    -b[0][1]
  ])));
}
function inverse(m) {
  var k2 = 1 / (m[0] * m[4] - m[1] * m[3]);
  return [
    k2 * m[4],
    -k2 * m[1],
    k2 * (m[1] * m[5] - m[2] * m[4]),
    -k2 * m[3],
    k2 * m[0],
    k2 * (m[2] * m[3] - m[0] * m[5])
  ];
}
function multiply(a, b) {
  return [
    a[0] * b[0] + a[1] * b[3],
    a[0] * b[1] + a[1] * b[4],
    a[0] * b[2] + a[1] * b[5] + a[2],
    a[3] * b[0] + a[4] * b[3],
    a[3] * b[1] + a[4] * b[4],
    a[3] * b[2] + a[4] * b[5] + a[5]
  ];
}
function subtract(a, b) {
  return [a[0] - b[0], a[1] - b[1]];
}
function length(v) {
  return sqrt(v[0] * v[0] + v[1] * v[1]);
}
function angle2(a, b) {
  return atan2(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1]);
}

// node_modules/d3-geo-projection/src/polyhedral/index.js
function polyhedral_default(root, face) {
  recurse(root, { transform: null });
  function recurse(node, parent) {
    node.edges = faceEdges(node.face);
    if (parent.face) {
      var shared = node.shared = sharedEdge(node.face, parent.face), m = matrix_default(shared.map(parent.project), shared.map(node.project));
      node.transform = parent.transform ? multiply(parent.transform, m) : m;
      var edges = parent.edges;
      for (var i = 0, n = edges.length; i < n; ++i) {
        if (pointEqual2(shared[0], edges[i][1]) && pointEqual2(shared[1], edges[i][0])) edges[i] = node;
        if (pointEqual2(shared[0], edges[i][0]) && pointEqual2(shared[1], edges[i][1])) edges[i] = node;
      }
      edges = node.edges;
      for (i = 0, n = edges.length; i < n; ++i) {
        if (pointEqual2(shared[0], edges[i][0]) && pointEqual2(shared[1], edges[i][1])) edges[i] = parent;
        if (pointEqual2(shared[0], edges[i][1]) && pointEqual2(shared[1], edges[i][0])) edges[i] = parent;
      }
    } else {
      node.transform = parent.transform;
    }
    if (node.children) {
      node.children.forEach(function(child) {
        recurse(child, node);
      });
    }
    return node;
  }
  function forward(lambda, phi) {
    var node = face(lambda, phi), point = node.project([lambda * degrees, phi * degrees]), t;
    if (t = node.transform) {
      return [
        t[0] * point[0] + t[1] * point[1] + t[2],
        -(t[3] * point[0] + t[4] * point[1] + t[5])
      ];
    }
    point[1] = -point[1];
    return point;
  }
  if (hasInverse(root)) forward.invert = function(x, y) {
    var coordinates = faceInvert(root, [x, -y]);
    return coordinates && (coordinates[0] *= radians, coordinates[1] *= radians, coordinates);
  };
  function faceInvert(node, coordinates) {
    var invert = node.project.invert, t = node.transform, point = coordinates;
    if (t) {
      t = inverse(t);
      point = [
        t[0] * point[0] + t[1] * point[1] + t[2],
        t[3] * point[0] + t[4] * point[1] + t[5]
      ];
    }
    if (invert && node === faceDegrees(p = invert(point))) return p;
    var p, children = node.children;
    for (var i = 0, n = children && children.length; i < n; ++i) {
      if (p = faceInvert(children[i], coordinates)) return p;
    }
  }
  function faceDegrees(coordinates) {
    return face(coordinates[0] * radians, coordinates[1] * radians);
  }
  var proj = projection(forward), stream_ = proj.stream;
  proj.stream = function(stream) {
    var rotate = proj.rotate(), rotateStream = stream_(stream), sphereStream = (proj.rotate([0, 0]), stream_(stream));
    proj.rotate(rotate);
    rotateStream.sphere = function() {
      sphereStream.polygonStart();
      sphereStream.lineStart();
      outline(sphereStream, root);
      sphereStream.lineEnd();
      sphereStream.polygonEnd();
    };
    return rotateStream;
  };
  return proj.angle(-30);
}
function outline(stream, node, parent) {
  var point, edges = node.edges, n = edges.length, edge, multiPoint = { type: "MultiPoint", coordinates: node.face }, notPoles = node.face.filter(function(d) {
    return abs(d[1]) !== 90;
  }), b = bounds_default({ type: "MultiPoint", coordinates: notPoles }), inside = false, j = -1, dx = b[1][0] - b[0][0];
  var c = dx === 180 || dx === 360 ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2] : centroid_default(multiPoint);
  if (parent) while (++j < n) {
    if (edges[j] === parent) break;
  }
  ++j;
  for (var i = 0; i < n; ++i) {
    edge = edges[(i + j) % n];
    if (Array.isArray(edge)) {
      if (!inside) {
        stream.point((point = interpolate_default(edge[0], c)(epsilon))[0], point[1]);
        inside = true;
      }
      stream.point((point = interpolate_default(edge[1], c)(epsilon))[0], point[1]);
    } else {
      inside = false;
      if (edge !== parent) outline(stream, edge, node);
    }
  }
}
function pointEqual2(a, b) {
  return a && b && a[0] === b[0] && a[1] === b[1];
}
function sharedEdge(a, b) {
  var x, y, n = a.length, found = null;
  for (var i = 0; i < n; ++i) {
    x = a[i];
    for (var j = b.length; --j >= 0; ) {
      y = b[j];
      if (x[0] === y[0] && x[1] === y[1]) {
        if (found) return [found, x];
        found = x;
      }
    }
  }
}
function faceEdges(face) {
  var n = face.length, edges = [];
  for (var a = face[n - 1], i = 0; i < n; ++i) edges.push([a, a = face[i]]);
  return edges;
}
function hasInverse(node) {
  return node.project.invert || node.children && node.children.some(hasInverse);
}

// node_modules/d3-geo-projection/src/polyhedral/octahedron.js
var octahedron = [
  [0, 90],
  [-90, 0],
  [0, 0],
  [90, 0],
  [180, 0],
  [0, -90]
];
var octahedron_default = [
  [0, 2, 1],
  [0, 3, 2],
  [5, 1, 2],
  [5, 2, 3],
  [0, 1, 4],
  [0, 4, 3],
  [5, 4, 1],
  [5, 3, 4]
].map(function(face) {
  return face.map(function(i) {
    return octahedron[i];
  });
});

// node_modules/d3-geo-projection/src/polyhedral/butterfly.js
function butterfly_default(faceProjection) {
  faceProjection = faceProjection || function(face) {
    var c = centroid_default({ type: "MultiPoint", coordinates: face });
    return gnomonic_default().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
  };
  var faces = octahedron_default.map(function(face) {
    return { face, project: faceProjection(face) };
  });
  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function(d, i) {
    var node = faces[d];
    node && (node.children || (node.children = [])).push(faces[i]);
  });
  return polyhedral_default(faces[0], function(lambda, phi) {
    return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
  }).angle(-30).scale(101.858).center([0, 45]);
}

// node_modules/d3-geo-projection/src/polyhedral/collignon.js
var kx = 2 / sqrt(3);
function collignonK(a, b) {
  var p = collignonRaw(a, b);
  return [p[0] * kx, p[1]];
}
collignonK.invert = function(x, y) {
  return collignonRaw.invert(x / kx, y);
};
function collignon_default2(faceProjection) {
  faceProjection = faceProjection || function(face) {
    var c = centroid_default({ type: "MultiPoint", coordinates: face });
    return projection(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180]);
  };
  var faces = octahedron_default.map(function(face) {
    return { face, project: faceProjection(face) };
  });
  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function(d, i) {
    var node = faces[d];
    node && (node.children || (node.children = [])).push(faces[i]);
  });
  return polyhedral_default(faces[0], function(lambda, phi) {
    return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
  }).angle(-30).scale(121.906).center([0, 48.5904]);
}

// node_modules/d3-geo-projection/src/polyhedral/waterman.js
function waterman_default(faceProjection) {
  faceProjection = faceProjection || function(face2) {
    var c = face2.length === 6 ? centroid_default({ type: "MultiPoint", coordinates: face2 }) : face2[0];
    return gnomonic_default().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
  };
  var w5 = octahedron_default.map(function(face2) {
    var xyz = face2.map(cartesian), n = xyz.length, a = xyz[n - 1], b, hexagon = [];
    for (var i = 0; i < n; ++i) {
      b = xyz[i];
      hexagon.push(spherical([
        a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794,
        a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794,
        a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794
      ]), spherical([
        b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794,
        b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794,
        b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794
      ]));
      a = b;
    }
    return hexagon;
  });
  var cornerNormals = [];
  var parents = [-1, 0, 0, 1, 0, 1, 4, 5];
  w5.forEach(function(hexagon, j) {
    var face2 = octahedron_default[j], n = face2.length, normals = cornerNormals[j] = [];
    for (var i = 0; i < n; ++i) {
      w5.push([
        face2[i],
        hexagon[(i * 2 + 2) % (2 * n)],
        hexagon[(i * 2 + 1) % (2 * n)]
      ]);
      parents.push(j);
      normals.push(cross(
        cartesian(hexagon[(i * 2 + 2) % (2 * n)]),
        cartesian(hexagon[(i * 2 + 1) % (2 * n)])
      ));
    }
  });
  var faces = w5.map(function(face2) {
    return {
      project: faceProjection(face2),
      face: face2
    };
  });
  parents.forEach(function(d, i) {
    var parent = faces[d];
    parent && (parent.children || (parent.children = [])).push(faces[i]);
  });
  function face(lambda, phi) {
    var cosphi = cos(phi), p = [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];
    var hexagon = lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5;
    var n = cornerNormals[hexagon];
    return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon];
  }
  return polyhedral_default(faces[0], face).angle(-30).scale(110.625).center([0, 45]);
}
function dot(a, b) {
  for (var i = 0, n = a.length, s = 0; i < n; ++i) s += a[i] * b[i];
  return s;
}
function cross(a, b) {
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0]
  ];
}
function spherical(cartesian2) {
  return [
    atan2(cartesian2[1], cartesian2[0]) * degrees,
    asin(max(-1, min(1, cartesian2[2]))) * degrees
  ];
}
function cartesian(coordinates) {
  var lambda = coordinates[0] * radians, phi = coordinates[1] * radians, cosphi = cos(phi);
  return [
    cosphi * cos(lambda),
    cosphi * sin(lambda),
    sin(phi)
  ];
}

// node_modules/d3-geo-projection/src/noop.js
var noop_default = () => {
};

// node_modules/d3-geo-projection/src/project/clockwise.js
function clockwise_default(ring) {
  if ((n = ring.length) < 4) return false;
  var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area <= 0;
}

// node_modules/d3-geo-projection/src/project/contains.js
function contains_default(ring, point) {
  var x = point[0], y = point[1], contains = false;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;
  }
  return contains;
}

// node_modules/d3-geo-projection/src/project/index.js
function project_default(object, projection2) {
  var stream = projection2.stream, project;
  if (!stream) throw new Error("invalid projection");
  switch (object && object.type) {
    case "Feature":
      project = projectFeature;
      break;
    case "FeatureCollection":
      project = projectFeatureCollection;
      break;
    default:
      project = projectGeometry;
      break;
  }
  return project(object, stream);
}
function projectFeatureCollection(o, stream) {
  return {
    type: "FeatureCollection",
    features: o.features.map(function(f) {
      return projectFeature(f, stream);
    })
  };
}
function projectFeature(o, stream) {
  return {
    type: "Feature",
    id: o.id,
    properties: o.properties,
    geometry: projectGeometry(o.geometry, stream)
  };
}
function projectGeometryCollection(o, stream) {
  return {
    type: "GeometryCollection",
    geometries: o.geometries.map(function(o2) {
      return projectGeometry(o2, stream);
    })
  };
}
function projectGeometry(o, stream) {
  if (!o) return null;
  if (o.type === "GeometryCollection") return projectGeometryCollection(o, stream);
  var sink;
  switch (o.type) {
    case "Point":
      sink = sinkPoint;
      break;
    case "MultiPoint":
      sink = sinkPoint;
      break;
    case "LineString":
      sink = sinkLine;
      break;
    case "MultiLineString":
      sink = sinkLine;
      break;
    case "Polygon":
      sink = sinkPolygon;
      break;
    case "MultiPolygon":
      sink = sinkPolygon;
      break;
    case "Sphere":
      sink = sinkPolygon;
      break;
    default:
      return null;
  }
  stream_default(o, stream(sink));
  return sink.result();
}
var points = [];
var lines = [];
var sinkPoint = {
  point: function(x, y) {
    points.push([x, y]);
  },
  result: function() {
    var result = !points.length ? null : points.length < 2 ? { type: "Point", coordinates: points[0] } : { type: "MultiPoint", coordinates: points };
    points = [];
    return result;
  }
};
var sinkLine = {
  lineStart: noop_default,
  point: function(x, y) {
    points.push([x, y]);
  },
  lineEnd: function() {
    if (points.length) lines.push(points), points = [];
  },
  result: function() {
    var result = !lines.length ? null : lines.length < 2 ? { type: "LineString", coordinates: lines[0] } : { type: "MultiLineString", coordinates: lines };
    lines = [];
    return result;
  }
};
var sinkPolygon = {
  polygonStart: noop_default,
  lineStart: noop_default,
  point: function(x, y) {
    points.push([x, y]);
  },
  lineEnd: function() {
    var n = points.length;
    if (n) {
      do
        points.push(points[0].slice());
      while (++n < 4);
      lines.push(points), points = [];
    }
  },
  polygonEnd: noop_default,
  result: function() {
    if (!lines.length) return null;
    var polygons = [], holes = [];
    lines.forEach(function(ring) {
      if (clockwise_default(ring)) polygons.push([ring]);
      else holes.push(ring);
    });
    holes.forEach(function(hole) {
      var point = hole[0];
      polygons.some(function(polygon) {
        if (contains_default(polygon[0], point)) {
          polygon.push(hole);
          return true;
        }
      }) || polygons.push([hole]);
    });
    lines = [];
    return !polygons.length ? null : polygons.length > 1 ? { type: "MultiPolygon", coordinates: polygons } : { type: "Polygon", coordinates: polygons[0] };
  }
};

// node_modules/d3-geo-projection/src/quincuncial/index.js
function quincuncial_default(project) {
  var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];
  function projectQuincuncial(lambda, phi) {
    var t = abs(lambda) < halfPi, p = project(t ? lambda : lambda > 0 ? lambda - pi : lambda + pi, phi), x = (p[0] - p[1]) * sqrt1_2, y = (p[0] + p[1]) * sqrt1_2;
    if (t) return [x, y];
    var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1;
    return [s * x - sign(y) * d, s * y - sign(x) * d];
  }
  if (project.invert) projectQuincuncial.invert = function(x02, y02) {
    var x = (x02 + y02) * sqrt1_2, y = (y02 - x02) * sqrt1_2, t = abs(x) < 0.5 * dx && abs(y) < 0.5 * dx;
    if (!t) {
      var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1, x12 = -s * x02 + (y > 0 ? 1 : -1) * d, y12 = -s * y02 + (x > 0 ? 1 : -1) * d;
      x = (-x12 - y12) * sqrt1_2;
      y = (x12 - y12) * sqrt1_2;
    }
    var p = project.invert(x, y);
    if (!t) p[0] += x > 0 ? pi : -pi;
    return p;
  };
  return projection(projectQuincuncial).rotate([-90, -90, 45]).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo-projection/src/quincuncial/gringorten.js
function gringorten_default2() {
  return quincuncial_default(gringortenRaw).scale(176.423);
}

// node_modules/d3-geo-projection/src/quincuncial/peirce.js
function peirce_default() {
  return quincuncial_default(guyouRaw).scale(111.48);
}

// node_modules/d3-geo-projection/src/quantize.js
function quantize_default(input, digits) {
  if (!(0 <= (digits = +digits) && digits <= 20)) throw new Error("invalid digits");
  function quantizePoint(input2) {
    var n = input2.length, i = 2, output2 = new Array(n);
    output2[0] = +input2[0].toFixed(digits);
    output2[1] = +input2[1].toFixed(digits);
    while (i < n) output2[i] = input2[i], ++i;
    return output2;
  }
  function quantizePoints(input2) {
    return input2.map(quantizePoint);
  }
  function quantizePointsNoDuplicates(input2) {
    var point0 = quantizePoint(input2[0]);
    var output2 = [point0];
    for (var i = 1; i < input2.length; i++) {
      var point = quantizePoint(input2[i]);
      if (point.length > 2 || point[0] != point0[0] || point[1] != point0[1]) {
        output2.push(point);
        point0 = point;
      }
    }
    if (output2.length === 1 && input2.length > 1) {
      output2.push(quantizePoint(input2[input2.length - 1]));
    }
    return output2;
  }
  function quantizePolygon(input2) {
    return input2.map(quantizePointsNoDuplicates);
  }
  function quantizeGeometry(input2) {
    if (input2 == null) return input2;
    var output2;
    switch (input2.type) {
      case "GeometryCollection":
        output2 = { type: "GeometryCollection", geometries: input2.geometries.map(quantizeGeometry) };
        break;
      case "Point":
        output2 = { type: "Point", coordinates: quantizePoint(input2.coordinates) };
        break;
      case "MultiPoint":
        output2 = { type: input2.type, coordinates: quantizePoints(input2.coordinates) };
        break;
      case "LineString":
        output2 = { type: input2.type, coordinates: quantizePointsNoDuplicates(input2.coordinates) };
        break;
      case "MultiLineString":
      case "Polygon":
        output2 = { type: input2.type, coordinates: quantizePolygon(input2.coordinates) };
        break;
      case "MultiPolygon":
        output2 = { type: "MultiPolygon", coordinates: input2.coordinates.map(quantizePolygon) };
        break;
      default:
        return input2;
    }
    if (input2.bbox != null) output2.bbox = input2.bbox;
    return output2;
  }
  function quantizeFeature(input2) {
    var output2 = { type: "Feature", properties: input2.properties, geometry: quantizeGeometry(input2.geometry) };
    if (input2.id != null) output2.id = input2.id;
    if (input2.bbox != null) output2.bbox = input2.bbox;
    return output2;
  }
  if (input != null) switch (input.type) {
    case "Feature":
      return quantizeFeature(input);
    case "FeatureCollection": {
      var output = { type: "FeatureCollection", features: input.features.map(quantizeFeature) };
      if (input.bbox != null) output.bbox = input.bbox;
      return output;
    }
    default:
      return quantizeGeometry(input);
  }
  return input;
}

// node_modules/d3-geo-projection/src/rectangularPolyconic.js
function rectangularPolyconicRaw(phi02) {
  var sinPhi0 = sin(phi02);
  function forward(lambda, phi) {
    var A2 = sinPhi0 ? tan(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;
    if (!phi) return [2 * A2, -phi02];
    var E = 2 * atan(A2 * sin(phi)), cotPhi = 1 / tan(phi);
    return [
      sin(E) * cotPhi,
      phi + (1 - cos(E)) * cotPhi - phi02
    ];
  }
  forward.invert = function(x, y) {
    if (abs(y += phi02) < epsilon) return [sinPhi0 ? 2 * atan(sinPhi0 * x / 2) / sinPhi0 : x, 0];
    var k2 = x * x + y * y, phi = 0, i = 10, delta;
    do {
      var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k2 - 2 * y * phi + phi * phi;
      phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
    } while (abs(delta) > epsilon && --i > 0);
    var E = x * (tanPhi = tan(phi)), A2 = tan(abs(y) < abs(phi + 1 / tanPhi) ? asin(E) * 0.5 : acos(E) * 0.5 + pi / 4) / sin(phi);
    return [
      sinPhi0 ? 2 * atan(sinPhi0 * A2) / sinPhi0 : 2 * A2,
      phi
    ];
  };
  return forward;
}
function rectangularPolyconic_default() {
  return parallel1_default(rectangularPolyconicRaw).scale(131.215);
}

// node_modules/d3-geo-projection/src/robinson.js
var K2 = [
  [0.9986, -0.062],
  [1, 0],
  [0.9986, 0.062],
  [0.9954, 0.124],
  [0.99, 0.186],
  [0.9822, 0.248],
  [0.973, 0.31],
  [0.96, 0.372],
  [0.9427, 0.434],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.835, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1]
];
K2.forEach(function(d) {
  d[1] *= 1.593415793900743;
});
function robinsonRaw(lambda, phi) {
  var i = min(18, abs(phi) * 36 / pi), i0 = floor(i), di = i - i0, ax = (k2 = K2[i0])[0], ay = k2[1], bx = (k2 = K2[++i0])[0], by = k2[1], cx = (k2 = K2[min(19, ++i0)])[0], cy = k2[1], k2;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    sign(phi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}
robinsonRaw.invert = function(x, y) {
  var phi = y * 90, i = min(18, abs(phi / 5)), i0 = max(0, floor(i));
  do {
    var ay = K2[i0][1], by = K2[i0 + 1][1], cy = K2[min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (abs(y) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));
    if (di >= 0 || i0 === 1) {
      phi = (y >= 0 ? 5 : -5) * (di + i);
      var j = 50, delta;
      do {
        i = min(18, abs(phi) / 5);
        i0 = floor(i);
        di = i - i0;
        ay = K2[i0][1];
        by = K2[i0 + 1][1];
        cy = K2[min(19, i0 + 2)][1];
        phi -= (delta = sign(y) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;
      } while (abs(delta) > epsilon2 && --j > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K2[i0][0], bx = K2[i0 + 1][0], cx = K2[min(19, i0 + 2)][0];
  return [
    x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi * radians
  ];
};
function robinson_default() {
  return projection(robinsonRaw).scale(152.63);
}

// node_modules/d3-geo-projection/src/satellite.js
function satelliteVerticalRaw(P) {
  function forward(lambda, phi) {
    var cosPhi = cos(phi), k2 = (P - 1) / (P - cosPhi * cos(lambda));
    return [
      k2 * cosPhi * sin(lambda),
      k2 * sin(phi)
    ];
  }
  forward.invert = function(x, y) {
    var rho2 = x * x + y * y, rho = sqrt(rho2), sinc = (P - sqrt(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));
    return [
      atan2(x * sinc, rho * sqrt(1 - sinc * sinc)),
      rho ? asin(y * sinc / rho) : 0
    ];
  };
  return forward;
}
function satelliteRaw(P, omega) {
  var vertical = satelliteVerticalRaw(P);
  if (!omega) return vertical;
  var cosOmega = cos(omega), sinOmega = sin(omega);
  function forward(lambda, phi) {
    var coordinates = vertical(lambda, phi), y = coordinates[1], A2 = y * sinOmega / (P - 1) + cosOmega;
    return [
      coordinates[0] * cosOmega / A2,
      y / A2
    ];
  }
  forward.invert = function(x, y) {
    var k2 = (P - 1) / (P - 1 - y * sinOmega);
    return vertical.invert(k2 * x, k2 * y * cosOmega);
  };
  return forward;
}
function satellite_default() {
  var distance2 = 2, omega = 0, m = projectionMutator(satelliteRaw), p = m(distance2, omega);
  p.distance = function(_) {
    if (!arguments.length) return distance2;
    return m(distance2 = +_, omega);
  };
  p.tilt = function(_) {
    if (!arguments.length) return omega * degrees;
    return m(distance2, omega = _ * radians);
  };
  return p.scale(432.147).clipAngle(acos(1 / distance2) * degrees - 1e-6);
}

// node_modules/d3-geo-projection/src/stitch.js
var epsilon3 = 1e-4;
var epsilonInverse = 1e4;
var x0 = -180;
var x0e = x0 + epsilon3;
var x1 = 180;
var x1e = x1 - epsilon3;
var y0 = -90;
var y0e = y0 + epsilon3;
var y1 = 90;
var y1e = y1 - epsilon3;
function nonempty(coordinates) {
  return coordinates.length > 0;
}
function quantize(x) {
  return Math.floor(x * epsilonInverse) / epsilonInverse;
}
function normalizePoint(y) {
  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)];
}
function clampPoint(p) {
  var x = p[0], y = p[1], clamped = false;
  if (x <= x0e) x = x0, clamped = true;
  else if (x >= x1e) x = x1, clamped = true;
  if (y <= y0e) y = y0, clamped = true;
  else if (y >= y1e) y = y1, clamped = true;
  return clamped ? [x, y] : p;
}
function clampPoints(points2) {
  return points2.map(clampPoint);
}
function extractFragments(rings, polygon, fragments) {
  for (var j = 0, m = rings.length; j < m; ++j) {
    var ring = rings[j].slice();
    fragments.push({ index: -1, polygon, ring });
    for (var i = 0, n = ring.length; i < n; ++i) {
      var point = ring[i], x = point[0], y = point[1];
      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {
        ring[i] = clampPoint(point);
        for (var k2 = i + 1; k2 < n; ++k2) {
          var pointk = ring[k2], xk = pointk[0], yk = pointk[1];
          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;
        }
        if (k2 === i + 1) continue;
        if (i) {
          var fragmentBefore = { index: -1, polygon, ring: ring.slice(0, i + 1) };
          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);
          fragments[fragments.length - 1] = fragmentBefore;
        } else fragments.pop();
        if (k2 >= n) break;
        fragments.push({ index: -1, polygon, ring: ring = ring.slice(k2 - 1) });
        ring[0] = normalizePoint(ring[0][1]);
        i = -1;
        n = ring.length;
      }
    }
  }
}
function stitchFragments(fragments) {
  var i, n = fragments.length;
  var fragmentByStart = {}, fragmentByEnd = {}, fragment, start, startFragment, end, endFragment;
  for (i = 0; i < n; ++i) {
    fragment = fragments[i];
    start = fragment.ring[0];
    end = fragment.ring[fragment.ring.length - 1];
    if (start[0] === end[0] && start[1] === end[1]) {
      fragment.polygon.push(fragment.ring);
      fragments[i] = null;
      continue;
    }
    fragment.index = i;
    fragmentByStart[start] = fragmentByEnd[end] = fragment;
  }
  for (i = 0; i < n; ++i) {
    fragment = fragments[i];
    if (fragment) {
      start = fragment.ring[0];
      end = fragment.ring[fragment.ring.length - 1];
      startFragment = fragmentByEnd[start];
      endFragment = fragmentByStart[end];
      delete fragmentByStart[start];
      delete fragmentByEnd[end];
      if (start[0] === end[0] && start[1] === end[1]) {
        fragment.polygon.push(fragment.ring);
        continue;
      }
      if (startFragment) {
        delete fragmentByEnd[start];
        delete fragmentByStart[startFragment.ring[0]];
        startFragment.ring.pop();
        fragments[startFragment.index] = null;
        fragment = { index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring) };
        if (startFragment === endFragment) {
          fragment.polygon.push(fragment.ring);
        } else {
          fragment.index = n++;
          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
        }
      } else if (endFragment) {
        delete fragmentByStart[end];
        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];
        fragment.ring.pop();
        fragment = { index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring) };
        fragments[endFragment.index] = null;
        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);
      } else {
        fragment.ring.push(fragment.ring[0]);
        fragment.polygon.push(fragment.ring);
      }
    }
  }
}
function stitchFeature(input) {
  var output = { type: "Feature", geometry: stitchGeometry(input.geometry) };
  if (input.id != null) output.id = input.id;
  if (input.bbox != null) output.bbox = input.bbox;
  if (input.properties != null) output.properties = input.properties;
  return output;
}
function stitchGeometry(input) {
  if (input == null) return input;
  var output, fragments, i, n;
  switch (input.type) {
    case "GeometryCollection":
      output = { type: "GeometryCollection", geometries: input.geometries.map(stitchGeometry) };
      break;
    case "Point":
      output = { type: "Point", coordinates: clampPoint(input.coordinates) };
      break;
    case "MultiPoint":
    case "LineString":
      output = { type: input.type, coordinates: clampPoints(input.coordinates) };
      break;
    case "MultiLineString":
      output = { type: "MultiLineString", coordinates: input.coordinates.map(clampPoints) };
      break;
    case "Polygon": {
      var polygon = [];
      extractFragments(input.coordinates, polygon, fragments = []);
      stitchFragments(fragments);
      output = { type: "Polygon", coordinates: polygon };
      break;
    }
    case "MultiPolygon": {
      fragments = [], i = -1, n = input.coordinates.length;
      var polygons = new Array(n);
      while (++i < n) extractFragments(input.coordinates[i], polygons[i] = [], fragments);
      stitchFragments(fragments);
      output = { type: "MultiPolygon", coordinates: polygons.filter(nonempty) };
      break;
    }
    default:
      return input;
  }
  if (input.bbox != null) output.bbox = input.bbox;
  return output;
}
function stitch_default(input) {
  if (input == null) return input;
  switch (input.type) {
    case "Feature":
      return stitchFeature(input);
    case "FeatureCollection": {
      var output = { type: "FeatureCollection", features: input.features.map(stitchFeature) };
      if (input.bbox != null) output.bbox = input.bbox;
      return output;
    }
    default:
      return stitchGeometry(input);
  }
}

// node_modules/d3-geo-projection/src/times.js
function timesRaw(lambda, phi) {
  var t = tan(phi / 2), s = sin(quarterPi * t);
  return [
    lambda * (0.74482 - 0.34588 * s * s),
    1.70711 * t
  ];
}
timesRaw.invert = function(x, y) {
  var t = y / 1.70711, s = sin(quarterPi * t);
  return [
    x / (0.74482 - 0.34588 * s * s),
    2 * atan(t)
  ];
};
function times_default() {
  return projection(timesRaw).scale(146.153);
}

// node_modules/d3-geo-projection/src/twoPoint.js
function twoPoint_default(raw, p0, p1) {
  var i = interpolate_default(p0, p1), o = i(0.5), a = rotation_default([-o[0], -o[1]])(p0), b = i.distance / 2, y = -asin(sin(a[1] * radians) / sin(b)), R = [-o[0], -o[1], -(a[0] > 0 ? pi - y : y) * degrees], p = projection(raw(b)).rotate(R), r = rotation_default(R), center = p.center;
  delete p.rotate;
  p.center = function(_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };
  return p.clipAngle(90);
}

// node_modules/d3-geo-projection/src/twoPointAzimuthal.js
function twoPointAzimuthalRaw(d) {
  var cosd = cos(d);
  function forward(lambda, phi) {
    var coordinates = gnomonicRaw(lambda, phi);
    coordinates[0] *= cosd;
    return coordinates;
  }
  forward.invert = function(x, y) {
    return gnomonicRaw.invert(x / cosd, y);
  };
  return forward;
}
function twoPointAzimuthalUsa() {
  return twoPointAzimuthal([-158, 21.5], [-77, 39]).clipAngle(60).scale(400);
}
function twoPointAzimuthal(p0, p1) {
  return twoPoint_default(twoPointAzimuthalRaw, p0, p1);
}

// node_modules/d3-geo-projection/src/twoPointEquidistant.js
function twoPointEquidistantRaw(z0) {
  if (!(z0 *= 2)) return azimuthalEquidistantRaw;
  var lambdaa = -z0 / 2, lambdab = -lambdaa, z02 = z0 * z0, tanLambda0 = tan(lambdab), S = 0.5 / sin(lambdab);
  function forward(lambda, phi) {
    var za = acos(cos(phi) * cos(lambda - lambdaa)), zb = acos(cos(phi) * cos(lambda - lambdab)), ys = phi < 0 ? -1 : 1;
    za *= za, zb *= zb;
    return [
      (za - zb) / (2 * z0),
      ys * sqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)
    ];
  }
  forward.invert = function(x, y) {
    var y2 = y * y, cosza = cos(sqrt(y2 + (t = x + lambdaa) * t)), coszb = cos(sqrt(y2 + (t = x + lambdab) * t)), t, d;
    return [
      atan2(d = cosza - coszb, t = (cosza + coszb) * tanLambda0),
      (y < 0 ? -1 : 1) * acos(sqrt(t * t + d * d) * S)
    ];
  };
  return forward;
}
function twoPointEquidistantUsa() {
  return twoPointEquidistant([-158, 21.5], [-77, 39]).clipAngle(130).scale(122.571);
}
function twoPointEquidistant(p0, p1) {
  return twoPoint_default(twoPointEquidistantRaw, p0, p1);
}

// node_modules/d3-geo-projection/src/vanDerGrinten.js
function vanDerGrintenRaw(lambda, phi) {
  if (abs(phi) < epsilon) return [lambda, 0];
  var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
  if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon) return [0, sign(phi) * pi * tan(theta / 2)];
  var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A22, G_P2 = G - P2, Q = A22 + G;
  return [
    sign(lambda) * pi * (A2 * G_P2 + sqrt(A22 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,
    sign(phi) * pi * (P * Q - A2 * sqrt((A22 + 1) * P2_A2 - Q * Q)) / P2_A2
  ];
}
vanDerGrintenRaw.invert = function(x, y) {
  if (abs(y) < epsilon) return [x, 0];
  if (abs(x) < epsilon) return [0, halfPi * sin(2 * atan(y / pi))];
  var x2 = (x /= pi) * x, y2 = (y /= pi) * y, x2_y2 = x2 + y2, z = x2_y2 * x2_y2, c1 = -abs(y) * (1 + x2_y2), c2 = c1 - 2 * y2 + x2, c3 = -2 * c1 + 1 + 2 * y2 + z, d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt(-a1 / 3), theta1 = acos(3 * d / (a1 * m1)) / 3;
  return [
    pi * (x2_y2 - 1 + sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x),
    sign(y) * pi * (-m1 * cos(theta1 + pi / 3) - c2 / (3 * c3))
  ];
};
function vanDerGrinten_default() {
  return projection(vanDerGrintenRaw).scale(79.4183);
}

// node_modules/d3-geo-projection/src/vanDerGrinten2.js
function vanDerGrinten2Raw(lambda, phi) {
  if (abs(phi) < epsilon) return [lambda, 0];
  var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
  if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon) return [0, sign(phi) * pi * tan(theta / 2)];
  var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, x12 = cosTheta * (sqrt(1 + A22) - A2 * cosTheta) / (1 + A22 * sinTheta * sinTheta);
  return [
    sign(lambda) * pi * x12,
    sign(phi) * pi * sqrt(1 - x12 * (2 * A2 + x12))
  ];
}
vanDerGrinten2Raw.invert = function(x, y) {
  if (!x) return [0, halfPi * sin(2 * atan(y / pi))];
  var x12 = abs(x / pi), A2 = (1 - x12 * x12 - (y /= pi) * y) / (2 * x12), A22 = A2 * A2, B2 = sqrt(A22 + 1);
  return [
    sign(x) * pi * (B2 - A2),
    sign(y) * halfPi * sin(2 * atan2(sqrt((1 - 2 * A2 * x12) * (A2 + B2) - x12), sqrt(B2 + A2 + x12)))
  ];
};
function vanDerGrinten2_default() {
  return projection(vanDerGrinten2Raw).scale(79.4183);
}

// node_modules/d3-geo-projection/src/vanDerGrinten3.js
function vanDerGrinten3Raw(lambda, phi) {
  if (abs(phi) < epsilon) return [lambda, 0];
  var sinTheta = phi / halfPi, theta = asin(sinTheta);
  if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon) return [0, pi * tan(theta / 2)];
  var A2 = (pi / lambda - lambda / pi) / 2, y12 = sinTheta / (1 + cos(theta));
  return [
    pi * (sign(lambda) * sqrt(A2 * A2 + 1 - y12 * y12) - A2),
    pi * y12
  ];
}
vanDerGrinten3Raw.invert = function(x, y) {
  if (!y) return [x, 0];
  var y12 = y / pi, A2 = (pi * pi * (1 - y12 * y12) - x * x) / (2 * pi * x);
  return [
    x ? pi * (sign(x) * sqrt(A2 * A2 + 1) - A2) : 0,
    halfPi * sin(2 * atan(y12))
  ];
};
function vanDerGrinten3_default() {
  return projection(vanDerGrinten3Raw).scale(79.4183);
}

// node_modules/d3-geo-projection/src/vanDerGrinten4.js
function vanDerGrinten4Raw(lambda, phi) {
  if (!phi) return [lambda, 0];
  var phi02 = abs(phi);
  if (!lambda || phi02 === halfPi) return [0, phi];
  var B2 = phi02 / halfPi, B22 = B2 * B2, C = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C2 = C * C, BC = B2 * C, B_C2 = B22 + C2 + 2 * BC, B_3C = B2 + 3 * C, lambda0 = lambda / halfPi, lambda1 = lambda0 + 1 / lambda0, D = sign(abs(lambda) - halfPi) * sqrt(lambda1 * lambda1 - 4), D2 = D * D, F = B_C2 * (B22 + C2 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2), x12 = (D * (B_C2 + C2 - 1) + 2 * sqrt(F)) / (4 * B_C2 + D2);
  return [
    sign(lambda) * halfPi * x12,
    sign(phi) * halfPi * sqrt(1 + D * abs(x12) - x12 * x12)
  ];
}
vanDerGrinten4Raw.invert = function(x, y) {
  var delta;
  if (!x || !y) return [x, y];
  var sy = sign(y);
  y = abs(y) / pi;
  var x12 = sign(x) * x / halfPi, D = (x12 * x12 - 1 + 4 * y * y) / abs(x12), D2 = D * D, B2 = y * (2 - (y > 0.5 ? min(y, abs(x)) : 0)), r = x * x + y * y, i = 50;
  do {
    var B22 = B2 * B2, C = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C_ = (3 * B2 - B22 * B2 - 10) / (2 * B22 * B2), C2 = C * C, BC = B2 * C, B_C = B2 + C, B_C2 = B_C * B_C, B_3C = B2 + 3 * C, F = B_C2 * (B22 + C2 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)), F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C2 * (-6 + 14 * B22 - D2 + (-8 + 8 * B22 - 2 * D2) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D2) * C_)), sqrtF = sqrt(F), f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x12 * (4 * B_C2 + D2), f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
    B2 -= delta = f / f_;
  } while (delta * r * r > epsilon && --i > 0);
  return [
    sign(x) * (sqrt(D * D + 4) + D) * pi / 4,
    sy * halfPi * B2
  ];
};
function vanDerGrinten4_default() {
  return projection(vanDerGrinten4Raw).scale(127.16);
}

// node_modules/d3-geo-projection/src/wagner.js
function wagnerFormula(cx, cy, m1, m2, n) {
  function forward(lambda, phi) {
    var s = m1 * sin(m2 * phi), c0 = sqrt(1 - s * s), c1 = sqrt(2 / (1 + c0 * cos(lambda *= n)));
    return [
      cx * c0 * c1 * sin(lambda),
      cy * s * c1
    ];
  }
  forward.invert = function(x, y) {
    var t1 = x / cx, t2 = y / cy, p = sqrt(t1 * t1 + t2 * t2), c = 2 * asin(p / 2);
    return [
      atan2(x * tan(c), cx * p) / n,
      p && asin(y * sin(c) / (cy * m1 * p)) / m2
    ];
  };
  return forward;
}
function wagnerRaw(poleline, parallels, inflation, ratio) {
  var phi1 = pi / 3;
  poleline = max(poleline, epsilon);
  parallels = max(parallels, epsilon);
  poleline = min(poleline, halfPi);
  parallels = min(parallels, pi - epsilon);
  inflation = max(inflation, 0);
  inflation = min(inflation, 100 - epsilon);
  ratio = max(ratio, epsilon);
  var vinflation = inflation / 100 + 1;
  var vratio = ratio / 100;
  var m2 = acos(vinflation * cos(phi1)) / phi1, m1 = sin(poleline) / sin(m2 * halfPi), n = parallels / pi, k2 = sqrt(vratio * sin(poleline / 2) / sin(parallels / 2)), cx = k2 / sqrt(n * m1 * m2), cy = 1 / (k2 * sqrt(n * m1 * m2));
  return wagnerFormula(cx, cy, m1, m2, n);
}
function wagner() {
  var poleline = 65 * radians, parallels = 60 * radians, inflation = 20, ratio = 200, mutate = projectionMutator(wagnerRaw), projection2 = mutate(poleline, parallels, inflation, ratio);
  projection2.poleline = function(_) {
    return arguments.length ? mutate(poleline = +_ * radians, parallels, inflation, ratio) : poleline * degrees;
  };
  projection2.parallels = function(_) {
    return arguments.length ? mutate(poleline, parallels = +_ * radians, inflation, ratio) : parallels * degrees;
  };
  projection2.inflation = function(_) {
    return arguments.length ? mutate(poleline, parallels, inflation = +_, ratio) : inflation;
  };
  projection2.ratio = function(_) {
    return arguments.length ? mutate(poleline, parallels, inflation, ratio = +_) : ratio;
  };
  return projection2.scale(163.775);
}
function wagner7() {
  return wagner().poleline(65).parallels(60).inflation(0).ratio(200).scale(172.633);
}

// node_modules/d3-geo-projection/src/wagner4.js
var A = 4 * pi + 3 * sqrt(3);
var B = 2 * sqrt(2 * pi * sqrt(3) / A);
var wagner4Raw = mollweideBromleyRaw(B * sqrt(3) / pi, B, A / 6);
function wagner4_default() {
  return projection(wagner4Raw).scale(176.84);
}

// node_modules/d3-geo-projection/src/wagner6.js
function wagner6Raw(lambda, phi) {
  return [lambda * sqrt(1 - 3 * phi * phi / (pi * pi)), phi];
}
wagner6Raw.invert = function(x, y) {
  return [x / sqrt(1 - 3 * y * y / (pi * pi)), y];
};
function wagner6_default() {
  return projection(wagner6Raw).scale(152.63);
}

// node_modules/d3-geo-projection/src/wiechel.js
function wiechelRaw(lambda, phi) {
  var cosPhi = cos(phi), sinPhi = cos(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos(lambda = atan2(sin(lambda) * cosPhi, -sin(phi))), sinLambda = sin(lambda);
  cosPhi = sqrt(1 - sinPhi * sinPhi);
  return [
    sinLambda * cosPhi - cosLambda * sin1_Phi,
    -cosLambda * cosPhi - sinLambda * sin1_Phi
  ];
}
wiechelRaw.invert = function(x, y) {
  var w2 = (x * x + y * y) / -2, k2 = sqrt(-w2 * (2 + w2)), b = y * w2 + x * k2, a = x * w2 - y * k2, D = sqrt(a * a + b * b);
  return [
    atan2(k2 * b, D * (1 + w2)),
    D ? -asin(k2 * a / D) : 0
  ];
};
function wiechel_default() {
  return projection(wiechelRaw).rotate([0, -90, 45]).scale(124.75).clipAngle(180 - 1e-3);
}

// node_modules/d3-geo-projection/src/winkel3.js
function winkel3Raw(lambda, phi) {
  var coordinates = aitoffRaw(lambda, phi);
  return [
    (coordinates[0] + lambda / halfPi) / 2,
    (coordinates[1] + phi) / 2
  ];
}
winkel3Raw.invert = function(x, y) {
  var lambda = x, phi = y, i = 25;
  do {
    var cosphi = cos(phi), sinphi = sin(phi), sin_2phi = sin(2 * phi), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin(lambda), coslambda_2 = cos(lambda / 2), sinlambda_2 = sin(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C = 1 - cos2phi * coslambda_2 * coslambda_2, E = C ? acos(cosphi * coslambda_2) * sqrt(F = 1 / C) : F = 0, F, fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / halfPi) - x, fy = 0.5 * (E * sinphi + phi) - y, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi, dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
    lambda -= dlambda, phi -= dphi;
  } while ((abs(dlambda) > epsilon || abs(dphi) > epsilon) && --i > 0);
  return [lambda, phi];
};
function winkel3_default() {
  return projection(winkel3Raw).scale(158.837);
}
export {
  airy_default as geoAiry,
  airyRaw as geoAiryRaw,
  aitoff_default as geoAitoff,
  aitoffRaw as geoAitoffRaw,
  armadillo_default as geoArmadillo,
  armadilloRaw as geoArmadilloRaw,
  august_default as geoAugust,
  augustRaw as geoAugustRaw,
  baker_default as geoBaker,
  bakerRaw as geoBakerRaw,
  berghaus_default as geoBerghaus,
  berghausRaw as geoBerghausRaw,
  bertin_default as geoBertin1953,
  bertin1953Raw as geoBertin1953Raw,
  boggs_default as geoBoggs,
  boggsRaw as geoBoggsRaw,
  bonne_default as geoBonne,
  bonneRaw as geoBonneRaw,
  bottomley_default as geoBottomley,
  bottomleyRaw as geoBottomleyRaw,
  bromley_default as geoBromley,
  bromleyRaw as geoBromleyRaw,
  chamberlin as geoChamberlin,
  chamberlinAfrica as geoChamberlinAfrica,
  chamberlinRaw as geoChamberlinRaw,
  collignon_default as geoCollignon,
  collignonRaw as geoCollignonRaw,
  craig_default as geoCraig,
  craigRaw as geoCraigRaw,
  craster_default as geoCraster,
  crasterRaw as geoCrasterRaw,
  cylindricalEqualArea_default as geoCylindricalEqualArea,
  cylindricalEqualAreaRaw as geoCylindricalEqualAreaRaw,
  cylindricalStereographic_default as geoCylindricalStereographic,
  cylindricalStereographicRaw as geoCylindricalStereographicRaw,
  eckert1_default as geoEckert1,
  eckert1Raw as geoEckert1Raw,
  eckert2_default as geoEckert2,
  eckert2Raw as geoEckert2Raw,
  eckert3_default as geoEckert3,
  eckert3Raw as geoEckert3Raw,
  eckert4_default as geoEckert4,
  eckert4Raw as geoEckert4Raw,
  eckert5_default as geoEckert5,
  eckert5Raw as geoEckert5Raw,
  eckert6_default as geoEckert6,
  eckert6Raw as geoEckert6Raw,
  eisenlohr_default as geoEisenlohr,
  eisenlohrRaw as geoEisenlohrRaw,
  fahey_default as geoFahey,
  faheyRaw as geoFaheyRaw,
  foucaut_default as geoFoucaut,
  foucautRaw as geoFoucautRaw,
  foucautSinusoidal_default as geoFoucautSinusoidal,
  foucautSinusoidalRaw as geoFoucautSinusoidalRaw,
  gilbert_default as geoGilbert,
  gingery_default as geoGingery,
  gingeryRaw as geoGingeryRaw,
  ginzburg4_default as geoGinzburg4,
  ginzburg4Raw as geoGinzburg4Raw,
  ginzburg5_default as geoGinzburg5,
  ginzburg5Raw as geoGinzburg5Raw,
  ginzburg6_default as geoGinzburg6,
  ginzburg6Raw as geoGinzburg6Raw,
  ginzburg8_default as geoGinzburg8,
  ginzburg8Raw as geoGinzburg8Raw,
  ginzburg9_default as geoGinzburg9,
  ginzburg9Raw as geoGinzburg9Raw,
  gringorten_default as geoGringorten,
  gringorten_default2 as geoGringortenQuincuncial,
  gringortenRaw as geoGringortenRaw,
  guyou_default as geoGuyou,
  guyouRaw as geoGuyouRaw,
  hammer_default as geoHammer,
  hammerRaw as geoHammerRaw,
  hammerRetroazimuthal_default as geoHammerRetroazimuthal,
  hammerRetroazimuthalRaw as geoHammerRetroazimuthalRaw,
  healpix_default as geoHealpix,
  healpixRaw as geoHealpixRaw,
  hill_default as geoHill,
  hillRaw as geoHillRaw,
  homolosine_default as geoHomolosine,
  homolosineRaw as geoHomolosineRaw,
  hufnagel_default as geoHufnagel,
  hufnagelRaw as geoHufnagelRaw,
  hyperelliptical_default as geoHyperelliptical,
  hyperellipticalRaw as geoHyperellipticalRaw,
  interrupted_default as geoInterrupt,
  boggs_default2 as geoInterruptedBoggs,
  homolosine_default2 as geoInterruptedHomolosine,
  mollweide_default2 as geoInterruptedMollweide,
  mollweideHemispheres_default as geoInterruptedMollweideHemispheres,
  quarticAuthalic_default as geoInterruptedQuarticAuthalic,
  sinuMollweide_default2 as geoInterruptedSinuMollweide,
  sinusoidal_default2 as geoInterruptedSinusoidal,
  kavrayskiy7_default as geoKavrayskiy7,
  kavrayskiy7Raw as geoKavrayskiy7Raw,
  lagrange_default as geoLagrange,
  lagrangeRaw as geoLagrangeRaw,
  larrivee_default as geoLarrivee,
  larriveeRaw as geoLarriveeRaw,
  laskowski_default as geoLaskowski,
  laskowskiRaw as geoLaskowskiRaw,
  littrow_default as geoLittrow,
  littrowRaw as geoLittrowRaw,
  loximuthal_default as geoLoximuthal,
  loximuthalRaw as geoLoximuthalRaw,
  miller_default as geoMiller,
  millerRaw as geoMillerRaw,
  modifiedStereographic as geoModifiedStereographic,
  modifiedStereographicAlaska as geoModifiedStereographicAlaska,
  modifiedStereographicGs48 as geoModifiedStereographicGs48,
  modifiedStereographicGs50 as geoModifiedStereographicGs50,
  modifiedStereographicLee as geoModifiedStereographicLee,
  modifiedStereographicMiller as geoModifiedStereographicMiller,
  modifiedStereographicRaw as geoModifiedStereographicRaw,
  mollweide_default as geoMollweide,
  mollweideRaw as geoMollweideRaw,
  mtFlatPolarParabolic_default as geoMtFlatPolarParabolic,
  mtFlatPolarParabolicRaw as geoMtFlatPolarParabolicRaw,
  mtFlatPolarQuartic_default as geoMtFlatPolarQuartic,
  mtFlatPolarQuarticRaw as geoMtFlatPolarQuarticRaw,
  mtFlatPolarSinusoidal_default as geoMtFlatPolarSinusoidal,
  mtFlatPolarSinusoidalRaw as geoMtFlatPolarSinusoidalRaw,
  naturalEarth2_default as geoNaturalEarth2,
  naturalEarth2Raw as geoNaturalEarth2Raw,
  nellHammer_default as geoNellHammer,
  nellHammerRaw as geoNellHammerRaw,
  nicolosi_default as geoNicolosi,
  nicolosiRaw as geoNicolosiRaw,
  patterson_default as geoPatterson,
  pattersonRaw as geoPattersonRaw,
  peirce_default as geoPeirceQuincuncial,
  polyconic_default as geoPolyconic,
  polyconicRaw as geoPolyconicRaw,
  polyhedral_default as geoPolyhedral,
  butterfly_default as geoPolyhedralButterfly,
  collignon_default2 as geoPolyhedralCollignon,
  waterman_default as geoPolyhedralWaterman,
  project_default as geoProject,
  quantize_default as geoQuantize,
  quincuncial_default as geoQuincuncial,
  rectangularPolyconic_default as geoRectangularPolyconic,
  rectangularPolyconicRaw as geoRectangularPolyconicRaw,
  robinson_default as geoRobinson,
  robinsonRaw as geoRobinsonRaw,
  satellite_default as geoSatellite,
  satelliteRaw as geoSatelliteRaw,
  sinuMollweide_default as geoSinuMollweide,
  sinuMollweideRaw as geoSinuMollweideRaw,
  sinusoidal_default as geoSinusoidal,
  sinusoidalRaw as geoSinusoidalRaw,
  stitch_default as geoStitch,
  times_default as geoTimes,
  timesRaw as geoTimesRaw,
  twoPointAzimuthal as geoTwoPointAzimuthal,
  twoPointAzimuthalRaw as geoTwoPointAzimuthalRaw,
  twoPointAzimuthalUsa as geoTwoPointAzimuthalUsa,
  twoPointEquidistant as geoTwoPointEquidistant,
  twoPointEquidistantRaw as geoTwoPointEquidistantRaw,
  twoPointEquidistantUsa as geoTwoPointEquidistantUsa,
  vanDerGrinten_default as geoVanDerGrinten,
  vanDerGrinten2_default as geoVanDerGrinten2,
  vanDerGrinten2Raw as geoVanDerGrinten2Raw,
  vanDerGrinten3_default as geoVanDerGrinten3,
  vanDerGrinten3Raw as geoVanDerGrinten3Raw,
  vanDerGrinten4_default as geoVanDerGrinten4,
  vanDerGrinten4Raw as geoVanDerGrinten4Raw,
  vanDerGrintenRaw as geoVanDerGrintenRaw,
  wagner as geoWagner,
  wagner4_default as geoWagner4,
  wagner4Raw as geoWagner4Raw,
  wagner6_default as geoWagner6,
  wagner6Raw as geoWagner6Raw,
  wagner7 as geoWagner7,
  wagnerRaw as geoWagnerRaw,
  wiechel_default as geoWiechel,
  wiechelRaw as geoWiechelRaw,
  winkel3_default as geoWinkel3,
  winkel3Raw as geoWinkel3Raw
};
//# sourceMappingURL=d3-geo-projection.js.map
